<font size = 4>

### HelloWorld
可以随便创建一个文本文件, 如`hello.out`, 键入如下内容:
```swift
print("hello world")
```
然后使用swift编译器可以直接运行
```bash
swift hello.out
```

从这一点来看, swift就像一个脚本解释器一样:
1. 程序没有入口, 即main函数.
2. 程序没有进行编译就能执行

事实上并非如此, 这个问题后续再说


### 字面量
严格来说单纯的字面量是没有类型的, 但编译器一般会默认一个类型, 如在c++中
```cpp
lb::cout << typeid(2).name() << lb::endl;       // i
int a = 20;
lb::cout << typeid(a).name() << lb::endl;       // i
```
> 两者打印是一样的, 所以默认的数字字面量会被编译器当作int类型, 在swift数字字面量默认是Int类型

```swift
print(type(of:2))               // Int
```

<br/>

### 常量
swift中使用let声明的对象是不可修改的, 声明和定义是可以分开的, 但定义后不允许赋值
```swift
let number1 = 20                    // 直接声明定义, 后续不能赋值

let number2: Int
print(number2)                      // 未初始化, 不能使用
number2 = 20                        // 用到时再定义, 后续不能赋值
//number2 = 30                      // error, 常量只能定义一次
print(number2)                      // 20
```

### 类型推导
在swift中对象的类型可以利用编译器推导出来, 前提是对象同时声明和定义
```swift
let n = 20                      // ok, 直接声明,定义, 编译器知道类型是Int
let s                           // error, 只有声明没有定义, 编译器不知道类型
let s2:String                   // ok, 只有声明, 但明确指定的对象的类型
```
> 这一点和c++中一样, c++类型推导时, 也是一样的规则

```cpp
auto i = 2;                     // ok, int
auto n;                         // error, 不知道类型
```


### 不会做类型转换
在swift中并不会隐匿的做类型转换
```swift
let a = 20
let b = 10.0
let c = a + b                   // error 类型不相同不能操作
```
> 在c++中会进行类型转换, 默认会将int转换为double


### 字符串基本操作
连接字符串的方式有3种:
1. `+`
2. `\()`
3. 使用String类相关的方法, 后续学习
```swift
let name = "tirrey"
let age = 20
let des = "name:" + name + "\tage:" + String(age)
let des = "name:\(name)age:\(String(age))"
```

### 多行字符串
用配对的三个双引号, 以最后的双引号边界为缩进
```swift
let s1 = """
hello                           
                """
// 错误的定义, hello必须第2个 """的左边界对齐

let s2 = """
        hello
            world
        """
print(s2)                       
    // hello
    //     world 
```

<br/>


### 数组的简单使用
使用`[]`可以创建数组, 最后一个元素可以使用逗号
```swift
var arr = ["hello", "tierry"]           // 变量, 后续有改值的操作, 不能使用常量
print(arr)                              // ["hello", tierry"]
arr[1] = "jerry"                        
print(arr)                              // ["hello", jerry"]
arr[2] = "tom"                          // runtime error, 越界
arr.apend("tom")                        // right, 在数组中添加元素, 新的元素在最后
```

### 字典
使用`[key:value]`可以创建字典, 最后一个元素可以使用逗号
```swift
var person = [
    "name":"tierry",
    "age":20
]
print (person)
person["name"] = "jerry"                // 修改对应name字段为jerry
```
> 相对于c++来说很简单


### 字典的遍历
```swift
// key是字符串, value是任意类型
let country : [String:Any] = [
    "name": "中国",
    "citys":[
        "上海","武汉","南京"
    ]
]

print(country)

for (key,val) in country {
    if key == "name" {
        print(val)
        continue
    }

    // 如果是citys则是一个数组, 但是在声明时指定的是Any
    // 所以这里转换成数组才行
    if key == "citys" {
        for city in val as! [String]{
            print(city)
        }
    }
}
```


### 控制流
if和switch:
1. 后面的括号可以省略, 一般情况下在swift中不加. 
2. 执行体必须加`{}`, 即使只有一条执行语句
3. 条件必须是bool值
```swift
let name = "tierry"
if "jerry" == name {
    print("I'm jerry")
}else {
    print("I'm tierry")
}

if name {       // error, 条件必须是一个bool
}
```

### 三元非三元
在cpp中很常用的一个操作是三元表达式
```cpp
int age = num > 150 && num < 0 ? 18 : num       // 不符合年龄的区间设置为18岁
```
在swift中也有同样的表达式
```swift
let num = 20
let age = num > 150 && num < 0 ? 18 : num       
```
同时可以:
```swift
let age = if num > 150 && num < 0 {
    18
}eles{
    num
}
```
这有点类似clang中的`({})`
```cpp
int num = 20;
int age = num > 150 && num < 0 ? ({18;}) : ({num;});
```


### 可选
可选类型相当于一个例子, 内部有值和标志2个区域, 值区域存储值, 标志区域标识值域有没有值

可选类型可以使用`!= nil`来作为if的条件判断
```swift
let num : Int? = 20             // 在类型后面加上?表示可选类型
print(num!)                     // 要取值时直接加!

if num != nil {
}else{
}
```
可以在初始化时, 直接将可选作为if的条件
```swift
let num : Int? = 20
if let age = num {              // __code_if
}else{
}
```
`__code_if`逻辑上是这样:
```swift
if num != nil{
    let age = num!              // 直接取出值(!)
}else{
    // 不可以访问age
}
```
所以`age`是一个局部变量. 不用纠结, 这个是固定语法!! 可以直接使用相同的名字来判断可选是否有值
```swift
let num : Int? = 20
if let num {                    // __code_if_num
    print(num)                  // num直接不用解包
}

let sum = num + 10              // error, num是可选类型, 必须解包
```
这里的`__code_if_num`相当于

```swift
if num != nil{
    let tmp_num = num!          // 构建了临时变量, scope内用到的num全替换成tmp_num
    print(tmp_num)                  
}
```

### switch
常规情况下switch中只能对数字进行比较, 并且case比较的数字必须是常量, 如C中.
```cpp
extern "C"{
void test(){
    int score = 70;
    const int _60 = 60;
    switch (num){
        case 0 ... 59:              // 范围比较, 非标准的C语法(clang, gcc)
            printf("不及格");
        break;
        case _60:                   // 直接使用常量作为csae的条件判断, 没有问题
            printf("刚及格");
        break;
        default:
            printf("优秀");
        break;
    }
}
}

int main(void){
    test();
}
```

### C++14以后的case字符串
在C++11以前case语句无法对字符串进行比较. 因为字符串比较的逻辑是运行时对比2字符串的相同位置的字符. 在C++11以后出现了`constexpr`关键字, 它修饰常量或函数, 主要功能体现在函数, 目的是告诉编译器函数的整个过程中函数内部的值全部是常量可以确定的, 举例来说:

```cpp
constexpr int test(const int a){
    a ^= a^100 + a << 31 + a >> 13
    return a;
}

auto r1 = test(2);        // 常量调用, 编译器会立即计算最后的结果, 假如是 0xff, 则当前位置直接被编译器替换成 auto r1 = static_cast<int>(0xff)

int n = 2;
auto r2 = test(n);          // 不是常量调用, 编译器会调用函数, 在运行时处理. 
```
通过constexpr函数, 可以为字符串字面量定义字符串到数字的转换, 这就是实现case字符串的原理. 下面是一个可行的案例. 用到了高级模板技巧
```cpp
namespace lb = std;

// 不同类型的hash

// 其他class或struct要自己加特化, 否则报错
template<typename T>size_t hash(T& val){    return val;     }

// int类型特化
template<> size_t hash<int>(int& val){  return val; }

// 指针类型特化
template<typename T> size_t hash(T* val){   return val; }

// const 指针特化
template<typename T> size_t hash(const T* val){ return val; }


// 声明成常量函数
constexpr static inline size_t cal_c_str(const char* val){
    size_t result = 0;
    auto ptr = const_cast<char*>(val);
    while(*ptr) result += *ptr++;
    return result;
}

// C字符串特化, 声明成constexpr 是为了case语句
template<> constexpr size_t hash(char* val){return cal_c_str(val);}
template<> constexpr size_t hash(const char* val){return cal_c_str(val);}



template<typename T>
constexpr void hash_combine(size_t& seed, const T& val){    //hash_algorithm
    seed ^= hash(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}
template<typename T>
constexpr void hash_val(size_t& seed, const T& val){    // hash_over
    hash_combine(seed, val);
}
template<typename T, typename... Types>
constexpr void hash_val(size_t& seed, const T& val, const Types&... args){  //hash_handle
    hash_combine(seed, val);
    hash_val(seed, args...);
}

template<typename... Types>
constexpr size_t hash_val(const Types&... args){    // hash_main
    size_t seed = 97;                               // 这个值随便取的, 可以规定一个比较大的质数      
    hash_val(seed, args...);
    return seed;
}


// c++14以上, 字符串字面量的后缀格式, 如: "hello"_code
// _code必须加`_`, 为了和标准库里的用法区分开
constexpr size_t operator "" _code(const char* val, size_t len) noexcept {
    return hash_val(val);
}


int main(int argc, const char * argv[]) {
    char abc[] = {'h', 'e', 'l', 'l', 'o', '\0'};
    char* tmp = abc;
    lb::cout << hash_val("hello") << lb::endl;
    lb::cout << hash_val(abc) << lb::endl;
    lb::cout << hash_val(tmp) << lb::endl;
    lb::cout << hash_val("world") << lb::endl;
    lb::cout << hash_val(lb::string("hello").c_str())<<lb::endl;
    lb::cout << hash_val(100)<<lb::endl;
    lb::cout << "hello"_code << lb::endl;

    switch (hash_val(lb::string("hello").c_str())) {
        case "hello"_code:
            lb::cout << "hello" << lb::endl;
            break;

        default:
            break;
    }
    return 0;
}
```

### swift的switch
在swift中对switch进行了扩展, 功能很强大
1. 可以直接比较字符串, 甚至是其他class对象
2. 参与比较的字符串可以是字符串字面量, 也可以是变量
3. 可以对比较对象作条件限制
4. 和C++中不同的是没有break, 不会自动穿透, 若要穿透则主动提供`fallthrough`
这里先介绍基本用法
```swift
let name = "tierry"

switch name {
case "jerry":
    print("I'm jerry")
case "tom":
    print("I'm tom")
case let op where op.hasSuffix("rry"):      // __code_case_let
    print("rry")
default:
    print("I'm tierry")
}
```
在这个demo中, `__code_case_let`对比较的字符串做限制, 必须是`rry`结尾, 当前name的值是`tierry`, 满足该比较条件, 但事实上`case "tierry"`更符合条件. 注意`__code_case_let`的条件在`case "tierry"`后面并不意味着swift就近原则, 会命中`case "tierry"`而不会管它的位置


### 循环
```swift
var n = 2
while n < 100 {
    n *= 2
}                   // 实际计算2的次幂
print(n)


var m = 2
repeat {
    m *= 2   
} while m < 100     // 类似于do-while
print(m)

var total = 0 
for i in 0..<4 {        // [0..3]
    total += i
}
print(total)
```


### 函数
```txt
func funname([call_tag | _ ] arg0 : type, ... ) -> ret_type{}
```
1. 必须要有函数名
2. 函数会向外提供调用标签
    1. call_tag: 外界调用时必须指定
    2. `_`: 外界调用可以省略
3. arg0:
    1. call_tag启用时, 函数内部引用的参数名
    2. `_`启用时, 同call_tag
    3. 当未提供`call_tag`和`_`时, 它就相当于`call_tag`, 同时是参数名
4. 返回值必须在最后
    1. `Void`可以不用写

```swift
func test(tag1 : String, tag2 arg2: String, _ arg3 : String) -> Void  {
    print(tag1);
    //print(tag2);      // 错误必须使用arg2
    print(arg2);        
    print(arg3);
}

// tag1必须指定, 因为提供了
// 第2个参数时,在调用时必须指定tag2, arg2不能用
// 第3个参数时,由于是忽略的, 所以不能指定
test(tag1: "hello", tag2: "world", "tierry")
```

### 使用元组返回多个值
```swift
func test(arg : (Int, Int)) -> (Int, Int)  {
    return (arg.1, arg.0)
}

let a : Int = 2, b : Int = 5
let result = test(arg: (a,b))
print(result.0)
print(result.1)
print(a)
print(b)
```
上述程序并未交换a和b的值

### 函数的嵌套
和swift中可以在函数中定义函数
```swift

func sum(number : Int) -> Int {
    var result = 0;
    func cal(){
        for i in 0...number {
            result += i
        }
    }
    cal()
    return result
}
print(sum(number: 10))
```
demo中在sum中又定义了cal, 主要功能是计算.


### 函数类型
在swift中函数也是一种类型, 所以它可以像其他类型一样作为参数和返回值

```swift
typealias DateData = (year: Int, month: Int, day: Int)

// __code_arg_is_func
func show_date(cout : (_ date : DateData)->Void, date : DateData) -> Void {
    cout(date)
}


func cout_0(date: DateData) -> Void {
    print("\(date.year)-\(date.month)-\(date.day)")
}

func cout_1(date: DateData) -> Void {
    print("\(date.month)\\\(date.day)\\\(date.year)")
}


let funcs = [
    cout_0,
    cout_1,
]

let date : DateData = (year: 2024, month:10, day:2)

for i in 0..<funcs.count {
    show_date(cout: funcs[i] , date: date)   
}
```

上述demo中定义了2个函数打印不同的日期格式. 但并不是直接调用它们, 而是在函数`show_date`中通过参数调用. `__code_arg_is_func`中当函数作为参数时, 参数声明必须为非占位. 此刻参数中的类型是函数类型, 当函数作为类型时,它们声明的参数必须是非占位的

```swift
let myfun1 : (date : DateData)->Void = cout_0       // error 声明一个函数类型,参数必须是非占位的
let myfun2 : (_ date : DateData)->Void = cout_0     // ok, 对外界来说, 省略了参数标签, 相当于没有占位
let myfun3 : (_ : DateData)->Void = cout_0          // ok, 同上
let myfun4 : (DateData)->Void = cout_0              // ok, 直接指定类型
```

函数作为参数的优势:函数内部易扩展, 像当前这个demo最大的优势是可以定义不同的实现而本身实现不需要作修改

### 函数作为返回值
同理因为函数是一种类型,所以当然可以作为另一个函数的返回值. 深究的话会牵扯到局部变量的内存问题, 也就是闭包的实现原理
```swift
 func get(type: String) -> (Double,Double)->Double{
    func add(_ fir: Double, _ two: Double)->Double{
        return fir + two
    }
    func sub(_ fir: Double, _ two: Double)->Double{
        return fir - two
    }
    func mul(_ fir: Double, _ two: Double)->Double{
        return fir * two
    }
    func div(_ fir: Double, _ two: Double)->Double{
        return fir / two
    }

    switch type.uppercased(){
        case "SUB":
            return sub
        case "MUL":
            return mul
        case "DIV":
            return div     
        default:
            return add
    }
}

print(get(type: "add")(2,3))
print(get(type: "mul")(2,3))
print(get(type: "div")(2,3))
print(get(type: "sub")(2,3))
```
上述demo中将加减乘除封装在了get函数内部,外界使用时,直接通过get函数的type来指定获取操作. 这里发现,在传递参数时发生了类型的隐式转换

</font>


### 局部变量的内存问题
先看一下测试
```swift
func out_func() -> ()->Void{
    var a :Int = 20                 // __code_local_var

    func iner_func(){
        a += 1
        print(a)
    }
    return iner_func
}

do{
    let inner_func = out_func()     
                                    // __code_out_func_stack_over
    inner_func()                    // __code_call_0
    inner_func()
    inner_func()
}
```
> 以下是打印结果:

```bash
21
22
23
```

这是一个很简单的测试, 程序先调用`out_func`获取到了内部的函数. 众所周知函数在可执行文件中中一定位于只读区, 所以`inner_func`看似在外层函数的局部作用域, 实际上它被编译成了单独的函数, 它内部引用了外层函数的局部变量, 从逻辑上来看出了外层函数的作用域再被调用时一定出问题,但事实调用的现象表明一点问题没有. 
笔者这里直接说原理吧: 编译器在遇到这种情况时, 会将内层函数`inner_func`编译到可执行文件的函数只读区. 如果`inner_func`引用了外层函数的局部变量, 则swift中的作法是创建一个对象,内部引用到函数的实现地址, 并在该对象中开辟一块内存初始化为外层函数的局部变量的值, 然后将这个对象返回给了外界, 外界用户层面对所谓的内部函数的操作最终在幕后被swift编译器展开成了这个对象的方法调用, 类似如下:

```swift
public struct __ref_{
    var mem_0 : Int
    mutating func exec(){
        mem_0 += 1
        print(mem_0)
    }
}


func out_func() -> __ref_{
    let a :Int = 20                 // __code_local_var
    let ref = __ref_(mem_0: a)
    return ref
}
```
外界产生的任何 inner_func()的调用, 都被编译器转换成了`ref.exec()`, 当ref的作用域消失后, 编译器会释放ref. 这就是闭包的原理, 所有的编译器都是这么做的. 在swift中:
1. 若内部函数没有引用到外层函数的局部变量, 则不会创建出对象, 后续发生所有的调用都将会直接转换成函数地址的直接调用.
2. 若引用了外层函数的局部变量但从未做任何更改, 并且是一个值引用, swift也不会创建对象, 效果同1
3. 若引用了外层函数的局部变量, 所引用的对象是值类型, 做了更改, 则也会创建对象
4. 若引用了外层函数的局部变量并且所引用的对象是引用类型, 则会创建对象. 
总之swift会充分考虑效率. 所有语言中的所谓的闭包都是这种原理. 本demo中内层函数引用了外层函数的局部变量, 还有一种情况是引用了函数的参数. 这到后面再说.

> 所以上述demo中, 调用3次`inner_func()`相当于调用了`ref.exec()`3次, 内部的变量地址没有变, 值是累加的

### 闭包的定义
这里为了理解, 以上小节的分析来定义闭包: 只要函数内部引用到了其他函数的局部变量, 编译器创建了新的对象去替换该函数的调用就产生了闭包. 官方定义的闭包是可以在后续被调用的代码, 从这一点来看函数也是一种闭包. 当然以笔者的定义也可以解释这一点, 这要从函数调用栈说起:

```swift
func f1(num : Int) -> Void{
    print("num:\(num)")
}

func test() -> Void {
    int a = 20
}
```




