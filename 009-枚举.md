<font size = 4>

# 枚举
### c++中
在讨论swfit的枚举前先来看一下c++中的枚举, 首先要在纯C环境下

```cpp

#define BEGIN_C namespace C{ extern "C" {
#define END_C }}

BEGIN_C

#define LB_ENUM(_name,_type)        \
typedef enum : _type{               \
    _name##a,                       \
    _name##b,                       \
    _name##c,                       \
    _name##d,                       \
    _name##e,                       \
    _name##f                        \
} _name;


void test(){
    LB_ENUM(T1, uint8_t)
    printf("%ld\n", sizeof(T1));            // 1

    LB_ENUM(T2, int)
    printf("%ld\n", sizeof(T2));            // 4

    LB_ENUM(T3, int64_t)
    printf("%ld\n", sizeof(T3));            // 8
}

END_C
```

demo中指定在C环境下定义不同类型的枚举, 在编译期得出的枚举类型占据的大小和类型有关. 但并不意味着最后生成的可执行文件中存储了枚举. 相反没有任何枚举相关的存储信息, 连常量区也没有枚举定义. 举例来说

```c
T1 t = T1_b;        // 1
```
这句代码使用T1定义了一个对象, 但编译器直接将枚举的值(`T1_b`)赋值给了该对象. 因为枚举在程序中是常量, 并且是编译期常量, 所以编译器不会为它分配空间, 直接将它出现的地方做字面量替换. 所以对象t本质就是`uint8_t`,它的大小是1个字节. 在C环境下可以直接将一个`uint8_t`的对象赋值给它. 针对这种情况c++11中出现了枚举类, 它限制了枚举的作用域


```cpp
enum class Condition : int64_t {
    False,
    True,
};
lb::cout << sizeof(Condition) << lb::endl;

auto condition = Condition::True;
condition = Condition::False;
condition = 0;                              // error, 不能被赋值枚举类外其他的值


do {
    lb::cout << "可以当作条件,直接读取的内存值\n"; 
}while(condition);                          // 只打印1次, condition内存的值实际是0

lb::cout << sizeof(condition) << lb::endl;  // 8
```
demo中的枚举占据8个字节, 这种类型的枚举限制了作用域. 而swift中的枚举扩展了很多功能, 内部实现机制涉及到了c++中的union. 下面来探究一下

### 基本枚举

```swift
enum Season{
    case spring
    case summer
    case autumn
    case winter
} 
```
这个是固定的语法, 不要纠结. 还可以以下面的格式定义:

```swift
enum Season{
    case spring, summer, autumn, winter
}
```

这些枚举的用法和c++中差不太多

```swift
enum Season{ case spring, summer, autumn, winter}

let s1 = Season.spring              // 由编译器推导类型
let s2: Season = .winter            // 由于指定了类型所以可以省略 Season前缀
var s3 = s1                         // 直接赋值
//s3 = 3                              // 错误, 类型和值不匹配

if s1 == .winter {                  // 因为s1已经确定了类型, 在比较时可以省略前缀
    print("winter")
}else{
    print("\(s1)")                  // spring
}

switch s2 {
case let tmp where tmp == .spring || tmp == .autumn:
    print("凉爽的季节")
case .summer:
    print("燥热的季节")
case .winter:
    print("寒冷的季节")

    // 其实上述条件已经将枚举列举完毕了, 笔者不明白的是为什么在报错
default:
    break
}
```

### 基本枚举的内存布局
枚举可以没有任何值(c++也可以), 在逻辑上它大小应该为0, 但编译器在实现时却不能将其视作0. 如下面swift中的空枚举
```swift
enum Score{}
print(MemoryLayout<Score>.size)         // 0    逻辑大小
print(MemoryLayout<Score>.stride)       // 1    实际编译器分配大小
print(MemoryLayout<Score>.alignment)    // 1    对齐参数
```

为了说明问题, 先看c++中的空枚举
```cpp
enum Condition : int64_t {};                // 空枚举
lb::cout << sizeof(Condition) << lb::endl;  // 但大小还是8

Condition condition;                        // 未初始化的局部变量
__builtin_memset(&condition, 1, sizeof(condition)); //因为是空枚举, 无法直接赋值, 但这里通过内存填充是被允许的

while (condition) {                         // 死循环
    lb::cout << "here\n";
} 
```
c++中的枚举本质还是整数, 所以即使是空枚举所定义的对象在逻辑上还是整数大小. 但在swift中就直接禁止创建空枚举对象, 可能swift认为空枚举没有成员就没有存在的意义

```swift
let s = Score()                         // error 没有任何构造方法, 所以不能定义对象
```

当基本枚举中有成员时, swift根据不同情况所做的优化是不一样的. 先来看只有1个成员的时候:

```swift
enum Score{
    case a
} 

print(MemoryLayout<Score>.size)         // 0
print(MemoryLayout<Score>.stride)       // 1
print(MemoryLayout<Score>.alignment)    // 1
```

这里感觉很诧异, 当有成员以后为什么编译器还不分配空间. 但不管怎样应该这种枚举必须能使用

```swift
let s = Score.a
```
不可以调用所谓的构造方法, 这里初始化的形式是固定的. 根据相关内存尺寸的打印, size为0表示对象不占据存储空间, 但编译器在实现功能时不能视为0, 它还是会分配1个字节的空间. 但里面的细节很还多. 下面做个试验:
```swift
let s  = Score.a

func cout(_ s: inout Score) {
    if s == .a {
        getchar()
        return
    }
}

cout(&s) 
```

汇编如下:

```lua
swift`main:
    0x100003850 <+0>:  stp    x29, x30, [sp, #-0x10]!           
    0x100003854 <+4>:  mov    x29, sp
->  0x100003858 <+8>:  bl     0x100003868               ; swift.cout(inout swift.Score) -> () at main.swift:25
                                                        ; cout函数明明有一个参数, 但这里在调用前未传递任何参数
    0x10000385c <+12>: mov    w0, #0x0
    0x100003860 <+16>: ldp    x29, x30, [sp], #0x10
    0x100003864 <+20>: ret    


;; 笔者这里测试了很多次, x0的值始终都是1, 而x1中存储的是命令行参数相关的地址


swift`cout(_:):
->  0x100003868 <+0>:  sub    sp, sp, #0x20
    0x10000386c <+4>:  stp    x29, x30, [sp, #0x10]
    0x100003870 <+8>:  add    x29, sp, #0x10
    0x100003874 <+12>: str    xzr, [sp, #0x8]
    0x100003878 <+16>: str    x0, [sp, #0x8]            ; 调用函数前(比较2个Score), x0表示1, x1没有意义
                                                        ; 所以这里相当于只给函数传递了1个参数, 事实上它需要2个
    0x10000387c <+20>: bl     0x1000038a0               ; static swift.Score.__derived_enum_equals(swift.Score, swift.Score) -> Swift.Bool at <compiler-generated>

                                                        ; 后面是比较结果
    0x100003880 <+24>: tbz    w0, #0x0, 0x100003890     ; <+40> at main.swift:30:1
    0x100003884 <+28>: b      0x100003888               ; <+32> at main.swift:27:9
    0x100003888 <+32>: bl     0x100003e60               ; symbol stub for: getchar
    0x10000388c <+36>: b      0x100003894               ; <+44> at main.swift:30:1
    0x100003890 <+40>: b      0x100003894               ; <+44> at main.swift:30:1
    0x100003894 <+44>: ldp    x29, x30, [sp, #0x10]
    0x100003898 <+48>: add    sp, sp, #0x20
    0x10000389c <+52>: ret
```

从这次汇编来看, 全局对象s没有任何轨迹, 可以理解为编译器根本没有为s分配内存(全局区). 即使这样从逻辑上也是成立的, 因为整个代码中所谓的全局对象s和Score就是等价的. 即使s被定义成var可以修改, 但事实上它的值还是唯一的. 所有出现s的地方都可以直接以Score来访问, swift中也确实这么做了, 但还有细节!! 在调用cout比较时, 传递的2个参数中, 第1个直接是数值1, 第2个直接不传. 这是swift的实现. 笔者认为所有接收`Score`的地方完全可以忽略参数的传递, 因为所有使用Score定义的对象其实和Score是等价的. 这里不再探究到底是为什么, 它是swift的一种实现罢了 

笔者针对上面的demo再次做了其他测试, 当主动获取s对象的内存地址时, swift奇迹的为s分配了内存!!!! 

```swift
var s  = Score.a
var n1 = 20
var n2 = 100
var n3 = Int.self


let s_addr = withUnsafeMutablePointer(to: &s){$0}
let n1_addr = withUnsafeMutablePointer(to: &n1){$0}
let n2_addr = withUnsafeMutablePointer(to: &n2){$0}
let n3_addr = withUnsafeMutablePointer(to: &n3){$0}

print(s_addr)           // 0x0000000100003290       s的内存地址, 目前不清楚
print(n1_addr)          // 0x0000000100008030       未初始化区, n1的地址
print(n2_addr)          // 0x0000000100008038       同上, n2的地址
print(n3_addr)          // 0x000000016fdff098       Int的类信息(Metadata), 栈上的内存
```
笔者猜想的应该是swift发现有用户要获取s的内存于是就分配了, 但这个分配的过程经过笔者调试, 并不是在程序运行起来后分配的(x1寄存器存储), 第1个从地址区域可以看出来, 它没有在堆中, 也不在栈, 同时它又不在全局区, 笔者目前不清楚这个地址怎么来的. 可能是swift在编译时就知道了有没有代码去获取s, 发现有这样的动作后就直接在可执行文件中给它了一个空间.


如果将成员修改为多个则此枚举所定义对象的内存中存储的就是整数, 绝大多数情况下对象的大小只占据一个字节. 编译期不允许访问到底层的整数. 这个可以从实现方案上来解释: 因为基本枚举中成员是固定的, 大多数情况下枚举成员的数量并不会太多, 使用1个字节就可以表示256种情况, 在编译期枚举的比较(如case,if等)都被编译器转换成整数序号的比较. 这样的实现方案不会浪费空间也提高了效率. 下面看下测试:

```swift
enum Score {
    case a
    case b
    case c
}

print(MemoryLayout<Score>.size)                 // 1
print(MemoryLayout<Score>.stride)               // 1
print(MemoryLayout<Score>.alignment)            // 1

func test(_ s: inout Score) {
    switch s {
    case .a :
        print("a")
    case .b :
        print("b")
    case .c :
        print("c")
    }
}

var s = Score.b
getchar()                                       // __code_break 断点
test(&s)
```

```lua
swift`main:
    0x100003318 <+0>:  sub    sp, sp, #0x40
    0x10000331c <+4>:  stp    x29, x30, [sp, #0x30]
    0x100003320 <+8>:  add    x29, sp, #0x30

    0x100003324 <+12>: adrp   x9, 5
    0x100003328 <+16>: adrp   x8, 5                     ; x8, x9指向了一个缓存表, 这个由swift维护
                                                        
    0x10000332c <+20>: add    x8, x8, #0x10             ; swift.s : swift.Score
                                                        ; x8指向了全局对象s的内存

    0x100003330 <+24>: str    x8, [sp, #0x8]            ; 将x8保存在局部对象中, 即某个局部变量var_tmp指向了s

    0x100003334 <+28>: mov    w8, #0x1                  ; w8(32) = 1
    0x100003338 <+32>: strb   w8, [x9, #0x10]           ; x9 + 0x10的内存, 即全局对象s的内存中存储为1

->  0x10000333c <+36>: bl     0x100003ddc               ; symbol stub for: getchar
                                                        ; 系统调用
                                                        








                                                        ;当前断点停留在这里, 笔者通过lldb修改对象a的内存值(下面)
                                                        ;   1. 先查看a的内存, 发现是1
                                                        ;   2. lldb修改为2
                                                        :   3. 放开断点进入到test后, 打印c(若不改内存, 则应该打印b)










    0x100003340 <+40>: ldr    x0, [sp, #0x8]
    0x100003344 <+44>: add    x1, sp, #0x18
    0x100003348 <+48>: str    x1, [sp, #0x10]
    0x10000334c <+52>: mov    w8, #0x21
    0x100003350 <+56>: mov    x2, x8
    0x100003354 <+60>: mov    x3, #0x0
    0x100003358 <+64>: bl     0x100003de8               ; symbol stub for: swift_beginAccess

    0x10000335c <+68>: ldr    x0, [sp, #0x8]            ; 前面var_tmp指向了全局对象a, 所以x8也指向a
    0x100003360 <+72>: bl     0x10000337c               ; swift.test(inout swift.Score) -> () at main.swift:12
                                                        ; 调用函数传递了a的地址
    0x100003364 <+76>: ldr    x0, [sp, #0x10]
    0x100003368 <+80>: bl     0x100003e54               ; symbol stub for: swift_endAccess
    0x10000336c <+84>: mov    w0, #0x0
    0x100003370 <+88>: ldp    x29, x30, [sp, #0x30]
    0x100003374 <+92>: add    sp, sp, #0x40
    0x100003378 <+96>: ret 








修改a的内存
(lldb) register read x9
      x9 = 0x0000000100008000  lazy protocol witness table cache variable for type swift.Score and conformance swift.Score : Swift.Hashable in swift
(lldb) x 0x0000000100008010                                                         ; a的内存地址, 存储的是1
0x100008010: 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x100008020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
(lldb) memory write 0x0000000100008010 -s 8 0x2                                     ; 修改为2
(lldb) x 0x0000000100008010                                                         ; 再次查看, 已经被改, 然后放开断点
0x100008010: 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
0x100008020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
```

最后程序打印的是`c`, 从汇编操作的过程来看, swift中基础枚举多于1个成员时:
- 枚举的大小还是为1, 因为1个字节足够对256个枚举成员编号
- 定义枚举对象会有内存分配
- 对象内存中存储是枚举成员的序号, 从0开始
- 所有在编译期所引用的枚举事实上全被编译器替换成了序号访问


<a id="link-swift-func-template"></a>

### 枚举的打印(初识)
枚举可以被字符串化, 但这个过程十分复杂, 由swift的运行库来做.

```swift
enum Number{
    case zero
    case one
    case three
    case four
}

print(Number.four)                                      // four
let descrip = String(describing: Number.four)           // four
print(descrip)                                          // four
```

运行后将枚举的成员字面值打印了出来. 这里简单介绍一下: swift本身是动态语言, 会将类型相关的信息存储在可执行文件中, 也就是metadata, 所以像枚举这种值类型的metadata在汇编中都是固定的地址值. 在swift中值类型的对象之所以效率高是因为对象本身并不存储指向metadata的指针, 它只有数据的内存空间,  在所有需要提供metadata地方由编译器直接传递固定的地址, 程序员不用管. 但是引用类型的对象必须多出metadata的空间, 意味着程序员可以改变引用对象的isa指针, 这就是所谓的动态反射, 后面学习. 

在demo中`String(describing:)`函数需要1个参数, 但编译器实际传递了至少2个参数给它. 
1. `Number.four`的枚举, 其实就是序号3
2. `Number`的类型, 即metadata

该函数本身是函数模板, 但和c++中的函数模板完全不是一个概念. c++中的函数模板只是一个模板, 在发生调用时不同的类型将生成不同的函数地址, 但swfit中的函数模板本身就是具体的函数实现, 但也是抽象的实现, 它依赖swift中的协议. 协议定义了行为, 函数模板中的类型必须遵循协议, 这就意味着函数模板所实现的功能被制约在协议下. 举例来说:

```swift
func greate_cmp<T>(t1: T, t2: T) -> Bool{
    t1 > t2
}
```

上述swift中的函数模板直接报错, 因为编译器不知道T的具体类型, 所以不知道t1和t2如何比较大小. swfit中将比较大小的功能抽象成了公共的协议`Comparable`,  所以只要告诉T类型遵循该协议, 则编译器就会确定t1和t2一定能比较大小

```swift
func greate_cmp<T>(t1: T, t2: T) -> Bool where T: Comparable{
    t1 > t2
}
```

但此函数模板还没这么简单, 它现在已经有了具体的实现了, 因为根据协议`greate_cmp`完全可以在不产生任何调用时就可以编译成单独的函数, 大致功能如下面的伪代码:

```txt
func greate_cmp<T>(t1: T, t2: T) -> Bool where T: Comparable{
   func compare = t1->metadata_ptr->compare_function
   return compare(t1, t2)
}
```
因为对于`greate_cmp`来说类型是不确定的, 每种类型的比较方法地址是不一样的, 所以函数内部必须先通过对象的isa指针(metadata)找到类的信息, 然后再找到比较的函数地址, 然后再调用比较函数. 所以说`greate_cmp`的实现是抽象的. 这种功能的函数模板牺牲了效率但节省了空间. 类似的在c++中完全不一样.

```cpp
struct ABC {};
struct BCD {
    bool operator > (const BCD&) const{
        return false;       // 始终返回false, 测试
    }
};

template <typename T>
auto greate_cmp(const T& t1, const T& t2) -> decltype(t1 > t2) {
    lb::cout << reinterpret_cast<void*>(static_cast<decltype(t1 > t2)(*)(const T&,const T&)>(greate_cmp)) << lb::endl;
    return t1 > t2;
}




int main(int args, char** argv){
    lb::cout << greate_cmp(2, 3) << lb::endl;                   // 0x100003c5c      0
    lb::cout << greate_cmp(2.0, 1.9) << lb::endl;               // 0x100003d3c      1
    lb::cout << greate_cmp(BCD(), BCD()) << lb::endl;           // 0x100003d98      0

//    lb::cout << greate_cmp(ABC(), ABC()) << lb::endl;         // error, 不能对ABC类型比较大小

    return 0;
} 
```

可以发现c++中的模板会编译2次, 一次是定义模板时,这种情况下只会看基本的语法是否符合. 后面发生调用时会再编译一次, 然后看能不能通过. 并且不同类型会生成不同的函数实现. 效率比swfit高. 笔者写这些是为了说明swift中的模板的基础过程, 所以上面`String(describing)`内部其实在我们定义枚举之前就已经实现了, 现在打印了枚举成员的字面字符串, 说明这些信息一定是编译器在编译代码时整理好了在它的metadata中, 这样函数内部才能找得到对应的信息. 后面的原始枚举以及可选(<font color = red>也是一种枚举</font>)会介绍枚举的字符串化



### 枚举的判断方案
正常情况下都是通过switch对枚举做判断, 但其实是case在对switch所传递的枚举对象和编号做比较, 所以只要在条件比较允许的地方写出编号比较的逻辑语句都是成立的
1. `if`
2. `if-case`
3. `swtich`
```swift
enum Season{ case spring, summer, autumn, winter}
let s: Season = .summer
if s == .summer {}

if case s = .summer {}

while s == .summer {}

switch s {
case .spring:
    break
case .summer:
    break
case .autumn:
    break
case .winter:
    break
}
```

### 遍历枚举
首先swift中遍历任何对象时必须通过迭代器,  默认情况下编译器不会对定义的枚举生成迭代器. 但编译器提供了系统的协议CaseIterable, 这个是语言层面的协议, 并不是特意为标准库开放的, 也就是说我们自定义的枚举也可遵循这个协议, 编译器就会自动为其生成`allCases`集合, 该集合内是所有的枚举对象

```swift
enum Season: CaseIterable{ case spring, summer, autumn, winter}

let c = Season.allCases;        // [.spring, .summer, .autumn, .winter] 

var it = c.makeIterator()

// 可选绑定
while let tmp = it.next(){
    print(tmp)
}

for item in c {
    print(item)
}
```

编译器自动生成了`allCases`的计算属性getter, 说白了就是为Season生成了一个静态方法, 该方法的功能是返回数组, 数组中存储的是所有Season枚举成员对应的对象. 这个过程是编译器完成的, 需要swift的运行库, 它要找到Season的metadata结构信息, 然后创建每一种枚举成员的对象放到数组中返回



### 原始枚举
基础枚举中编译器屏蔽了底层的序号, 外界用户使用时只能单一的进行成员比对, 即基础枚举所携带的信息有限. 在C中枚举至少可以参与整数的运算. 为此swift提供了原始枚举

```swift
enum 中文数字: Int{
    case 零
    case 壹
    case 贰
    case 叁
    case 肆
    case 伍
}

func chinese_number(is number: 中文数字) {
    print("中文\(number)")
}

let zero = 中文数字.零
let one: 中文数字 = .壹

chinese_number(is: zero)            // 中文零
chinese_number(is: one)             // 中文壹
```

原始枚举在定义时必须指定类型, 但这个类型并不决定枚举的内存布局(<font color = red>后续的小节探究</font>). 既然指定了类型则应该可以对枚举成员指定相关的值. demo中并没有指定实际上, 以整数来说:
1. 若原始枚举未指定相关的数值, 则成员的数值默认从0开始, 往上递增
2. 成员变量的值可以指定, 但不能重复
3. 成员变量的值并不是底层的序号编号

可以通过特定的方法获取到枚举成员的值, 该值称为原始值

```swift
func translate(to number: 中文数字) {
    print("\(number)阿拉伯数字为\(number.rawValue)")
}

translate(to: 中文数字.肆)
translate(to: 中文数字.伍)

//肆阿拉伯数字为4
//伍阿拉伯数字为5
```

可以调用`rawValue`(计算属性)来获取到枚举成员的原始值. 这里需要强调一点: 不管是基础枚举还是原始枚举它们在发生匹配时, 比较的底层还是未变, 还是以底层的编号为前提. 下面写代码来验证:
1. 验证原始枚举的大小还是1
2. 验证枚举对象中存储的是序号

```swift
enum Province: Int{
    case beijing = 11
    case hubei = 42
    case shanghai = 31
}

print(MemoryLayout<Province>.size)          // 1
print(MemoryLayout<Province>.stride)        // 1
print(MemoryLayout<Province>.alignment)     // 1

var p: Province = .beijing


// 获取p的内存地址
let ptr = withUnsafeMutablePointer(to: &p){UnsafeMutableRawPointer($0)}         

print("p addr:\(ptr)")                  // p addr:0x0000000100008010


// 读取内存数据, 因为测试出的大小是1个字节, 这里直接使用1个字节的类型来存储
var load_res = ptr.load(fromByteOffset: 0, as: UInt8.self)
print(load_res)                         // 0

p = Province.hubei
load_res = ptr.load(fromByteOffset: 0, as: UInt8.self)
print(load_res)                         // 1

p = Province.shanghai
load_res = ptr.load(fromByteOffset: 0, as: UInt8.self)
print(load_res)                         // 2
```

这些函数是swift中提供的, 笔者认为没有必要再在汇编中查看, 这样看简单一些. 可以发现原始枚举中对象的内存还是底层成员的编号, 和原始值没有任何关系, 所以在case或if时枚举比较的规则还是没有变化. 那rawValue的值存储在哪里? 

可以试想一下rawValue是通过枚举对象调用相关的方法, 所以是不是编译器为原始枚举背后生成了方法? 事实上枚举中确实可以定义成员方法. 现在能确定的是原始枚举对象的内存中和原始值没有任何关联,则可能的情况是原始值存储在metadata中(<font color = red>后面再学习</font>). 但也有另一种情况: 编译器在发现用户访问到相关的枚举时,直接在编译期填充了访问的地点. 举例来说:

```swift
p = .hubei
print(p.rawValue)                       // 编译器发现这里在访问rawValue, 则直接将这里填充为 print(42)
```
这种实现方案感觉上是更高效, 因为根本不需要存储枚举的原始值信息到可执行文件中(metadata), SRT启动的也就更高效. 毕竟这些值是固定的也不能改, 编译器完全可以在编译期间像字面量一样直接替换所有它出现的地方. 但仔细想来这样会存在这样一个问题:
1. 外界是通过变量在调用, 则每次`p.rawValue`时可能都不一样, 因为p可能修改, 所以编译器并不能直接做替换, 编译器要做更多的工作, 先访问p的内存查找到当前p的编号, 然后再对应去匹配
2. 若一个动态库中定义了枚举, 外界使用时, 编译器必须看到枚举的声明来为当前用户代码做枚举的编译, 若写动态库时编译器的版本和目前写代码时编译器的版本不一致则可能对同一枚举编译规则不一样, 就会出问题

直接通过汇编来查看

```lua
swift`main:
    0x10000361c <+0>:  stp    x29, x30, [sp, #-0x10]!
    0x100003620 <+4>:  mov    x29, sp
    0x100003624 <+8>:  mov    w0, #0x1                  ; 准备调用rawValue.getter函数
                                                        ;   根据注释rawValue.getter函数不需要参数, 但从实现的角度来看, 至少需要2个参数
                                                        ;       1. 枚举类型
                                                        :       2. 哪个枚举成员, 即编号, 所以传递了1
                                                        ;   rawValue.gtter方法是Province的成员方法, 所以可以推断不同类型的原始枚举中的rawValue是独立的
                                                        ;       所以不需要类型参数

    0x100003628 <+12>: bl     0x100003640               ; swift.Province.rawValue.getter : Swift.Int at <compiler-generated>
                                                        ;   调用成员方法, 注释特意标明了是编译器通用函数, 也就是说是编译器为Province生成了该成员方法
                                                        ;   汇编在下面
                                    
->  0x10000362c <+16>: adrp   x8, 5                     ; 一个全局区的地址, 通过它可以找到全局对象的内存地址
    0x100003630 <+20>: str    x0, [x8, #0x10]           ; 全局对象raw的地址, 将rawValue.getter中的返回的值(x0)填充到raw中
    0x100003634 <+24>: mov    w0, #0x0                  ; 清零
    0x100003638 <+28>: ldp    x29, x30, [sp], #0x10
    0x10000363c <+32>: ret 







->  0x100003640 <+0>:   sub    sp, sp, #0x20
    0x100003644 <+4>:   str    w0, [sp, #0x14]          ; *(sp + 0x14) = w0, 保存1到局部变量中, 因为调用函数前w0的值就是1
    0x100003648 <+8>:   strb   wzr, [sp, #0x18]         ; *(sp + 0x18) = 0(8位操作)  
    0x10000364c <+12>:  strb   w0, [sp, #0x18]          ; *(sp + 0x18) = 1(8位)
    0x100003650 <+16>:  ands   w8, w0, #0xff            ; w8 = w0 & 0xff
    0x100003654 <+20>:  cset   w8, eq                   ; w8 == 1?, 若是1则标记位置1
    0x100003658 <+24>:  tbnz   w8, #0x0, 0x10000367c    ; <+60> at <compiler-generated>
                                                        ; 查看w8的第0位是不是1, 若是1则跳转 __asm_0
    0x10000365c <+28>:  b      0x100003660              ; <+32> at <compiler-generated>
                                                        ; 若不是1则跳转到 __asm_1

    0x100003660 <+32>:  ldr    w8, [sp, #0x14]          ; w8 = *(sp + 0x14)                     ; __asm_1
                                                        ;   前面为了比较w8做了and操作             
                                                        ;   这里是重新取出值再比较其他的枚举成员序号

    0x100003664 <+36>:  and    w8, w8, #0xff            ; w8 = w8 & 0xff
    0x100003668 <+40>:  subs   w8, w8, #0x1             ; w8 = w8 - 1
    0x10000366c <+44>:  cset   w8, eq                   ; w8 == 1? 因为w8减了1, 所以这一步在判断传递过来的序号是不是2
    0x100003670 <+48>:  tbnz   w8, #0x0, 0x100003688    ; <+72> at main.swift
                                                        ;   检查w8的第0位是不是1, 若是1则跳转到 __asm_2
                                                        ;   并且后续 __asm_2的汇编就是在准备返回42(0x2a), 即枚举成员hubei


    0x100003674 <+52>:  b      0x100003678              ; <+56> at <compiler-generated>
                                                        ; 编号为2不成立, 则跳转到 __asm_3

    0x100003678 <+56>:  b      0x100003694              ; <+84> at main.swift                  ; __asm_3
                                                        ;   跳转 __asm_4
                                                        ;   前面比较了1和2种编号, 在Province中总共3个编号, 所以可以在 __asm_4 直接
                                                        ;   返回0编号的原始值, 即 31(0x1f, shanghai)


    0x10000367c <+60>:  mov    w8, #0xb                 ; 编号是1成立, 准备返回11(0xb, beijing) ;__asm_0
    0x100003680 <+64>:  str    x8, [sp, #0x8]           ; *(sp + 0x8) = w8, 保存要返回的原始值到局部变量中
    0x100003684 <+68>:  b      0x1000036a0              ; <+96> at main.swift
                                                        ;   返回

    0x100003688 <+72>:  mov    w8, #0x2a                                                        ; __asm_2
    0x10000368c <+76>:  str    x8, [sp, #0x8]           
    0x100003690 <+80>:  b      0x1000036a0              ; <+96> at main.swift
                                                        ;   返回
    0x100003694 <+84>:  mov    w8, #0x1f                                                        ; __asm_4
    0x100003698 <+88>:  str    x8, [sp, #0x8]
    0x10000369c <+92>:  b      0x1000036a0              ; <+96> at main.swift
                                                        ;   返回

    0x1000036a0 <+96>:  ldr    x0, [sp, #0x8]           ; w8 = *(sp + 0x8), 取出结果准备返回
    0x1000036a4 <+100>: add    sp, sp, #0x20
    0x1000036a8 <+104>: ret    
```

从汇编可以明显的看出`rawValue`的访问就是成员方法, 并且对于原始枚举编译器会提供默认的`rawValue.getter`的实现, 每个原始枚举的实现是独立的, 写成代码大致如下:

```swift
enum Province: Int{
    case beijing = 11
    case hubei = 42
    case shanghai = 31

    func rawValue() -> Int {
        let result: Int
        switch self {
        case .beijing :
            result = 11
        case .hubei :
            result = 22
        default:
            result = 31
        }
        return result
    }
} 


let raw = Province.hubei.rawValue()
```

> 这个是看了汇编后模拟出来的, 和编译器只存在调用形式上的区别. 这里稍微提一下: rawValue在swift中被称为计算属性, 并不是成员方法. 说白了就是固定的语法, 但它本质还是函数. 后续会学习. 

在原始枚举中还可以从一个原始值来获取创建枚举对象, 原始值在枚举中必须是唯一的在逻辑上和编号唯一对应, 所以一个合理的原始值可以对应上一个枚举成员, 但若值不合法则不应该创建枚举对象, 综合起来就是返回一个可选类型

```swift
let p1 = Province.init(rawValue: 31)            // 通过原始值31创建枚举, 这种可以创建成功
print(String(describing: p1))                   // 打印值, 使用String(describing)会忽略警告
let p2 = Province(rawValue: 30)                 // 没有原始值为30的枚举成员, 返回nil
print(String(describing: p2))                   

#if false
Optional(swift.Province.shanghai)               // 通过31返回的枚举对象, 但也是可选类型
nil                                             // 通过30返回的枚举对象, 为nil
#endif
```

原始枚举中的原始值可以直接参与运算. 像上面的类型为Int的原始枚举, 获取到原始值后,可以直接当作整数

```swift
let n1: Province.RawValue = 2                   // Province.RawValue通过类型访问, 它是一个typealias的类型
let n2 = Province.beijing.rawValue              // n2直接通过枚举成员获取的原始值(一定存在), 类型就是Int
print(type(of: n1))                             // Int
print(type(of: n2))                             // Int
print(n1 - 20)                                  // 直接当作整数来参与运算
print(n2 + 20) 
```

总结:
1. 原始枚举中的原始值不会存储枚举的metadata中(<font color = red>目前从整数来看</font>), 相反若不提供对应的计算属性(<font color = red> 后续学习</font>)时将由编译器生成, 并且是固定的成员方法
2. 原始枚举就是c++中的标准枚举, 只是语法不同


### 原始枚举(字符串)
虽然原始枚举的定义语法中不存在模板类型, 但swift对待原始枚举还可以指定其他类型, 系统提供了3种原始枚举类型:
1. 整数
2. Float
3. String

现在直接来探究字符串下的原始枚举

```swift
enum Province: String{
    case beijing
    case hubei
}


let str = Province.beijing.rawValue
print(str)      // "beijing"
let str2=String(describing: Province.beijing)
print(str2)     // "beijing" 
```

这2种方式结果都是字符串, 但第1种方式是通过访问编译器为其提供的rawValue成员方法, 内部的实现和前面整数一样大致过程是:

```swift
func rawValue() -> String{
    siwtch self {
        case .beijing: 
            return "begjing"
        defualt:
            return "hubei"
}
```
可以发现这些值是编译器从全局区拿到的, 也就是说编译器对待字符串的原始枚举类型时, 也不会将成员的原始值存储到metadata中, 直接在常量区. 需要的时候从常量区获取的. 但第2种使用字符串构建时是swfit运行时库处理的, 会用到Province的metadata.  简单提一下枚举成员字符串化时大致流程, 这个要结合swift的源码, 这里只是简单提一下, 后面学习字符串时会详细学习:

```swift
let str =String(describing: Province.beijing)
```

<a id="link-enum-string"></a>

上述代码使用枚举成员来字符串化, 默认情况下结果就是"beijing", 当然这个过程非常复杂:
1. 调用`String.init<T>(describing: T\{Province.beijing}) -> String`
2. 调用`OutputStream.swift中的函数_print_unlocked`
3. 调用`OutputStream.swift中的函数_adHocPrint_unlocked`
4. 调用到c++的函数`ReflectionMirror.cpp中的函数swift_EnumCaseName`
5. 调用`ReflectionMirror.cpp中的函数call函数`

这个过程中参数的传递:

```txt
1. 用户调用 String.init
    x0: Province.beijing, 实际就是枚举成员的序号, 为0
    x1: Province->metadata指针, 

    PS: 虽然String.init(describing)只接收一个参数, 但它必须附加一个类型,
        编译器将直接从全局区获取Province的metadata传递给x1.
        从这里可以看出Province的metadata直接被编译到了可执行文件中, 
        swift启动后这些数据就被内核加载到了程序的全局区, 当然这些数据在使用时要转换成
        相应的数据结构

    函数内部:
        直接创建了一个str<String>, 空字符串, 然后直接 self = str

    调用下个函数:
        _print_unlocked(Province.beijing, &self)

2. init调用 _print_unlocked
    由String.init传递过来
    参数1: Province.beijing, 就是序号1
    参数2: &str的地址

    函数内部:
        let mirror = Mirror(reflecting: value)  
            创建镜像对象, 这里value就是Province.Beijing,序号是1, Mirror构造函数的内部可以通过寄存器找到Province.metadata
            
    调用下个函数:
        _adHocPrint_unlocked(value, mirror, &target, isDebugPrint: false)
            target表示&str

3. _adHocPrint_unlocked
    函数内部
        ...
        
        case .enum :
            cString = _getEnumCaseName(Province.beijing)
                这由函数在c++中实现, c++会解析Province的Metadata, 取出序号1对应的枚举成员元信息, 即"beijing"这个原始值
            caseName = String(Cstring), 构造swift中的String返回到用户
        ...
 
4. swift_EnumCaseName(返回const char*)
    函数内部
        T表示Province.beijing, T表示Province.metadata_ptr
        return call(value, T, nullptr, [](ReflectionMirrorImpl *impl) { return impl->enumCaseName(); });

5. call函数
    解析metadata, 这个过程将通过序号1取出原始值字符串"beijing"
```

上面是源码的大致过程. 笔者只在说明枚举成员被字符串化时并不是一个简单的过程, 里面涉及到动态反射的代码处理. 实际如果一个枚举遵循了相关的协议后, 处理过程又变了:

```swift
enum Province: String, CustomStringConvertible{
    var description: String {
        switch self  {
        case .beijing :
            return "北京"
        case .hubei :
            return "湖北"
        }
    }
    case beijing
    case hubei
}

let p = String(describing: Province.hubei) // 湖北
print(p)
```
上述代码中枚举遵循了`CustomStringConvertible`协议, 则`String.init(describing)`函数内部会被swift的动态库检查到Province所遵循的协议, 然后直接回调到函数中, 所以返回了用户自定义的数据


### 自定义的枚举rawValue
原始枚举的rawValue[^ann-enum-raw]是计算属性, 实际也是编译器提供的系统协议, 这个也是语言层面的, 只不过原始枚举默认情况下由编译器生成了rawValue, 定义原始枚举时可以不指定(<font color = red>即使指定了也不用实现</font>). 其他非原始枚举要想要这个属性就要遵循`RawRepresentable`, 然后实现对应的rawValue的getter以及相关的初始化方法
```swift
enum Season: CaseIterable, RawRepresentable{
    case spring, summer, autumn, winter

    // 没有通过rawValue找到时
    // 该方法的原型是 init?(rawValue: String)
    // 当外界调用Season(rawValue:)时来这里初始化
    // 可以将问号直接去掉, 没有通过rawValue找到时, 默认初始化为 .spring
    init(rawValue: String) {
        switch rawValue {
        case "春天":
            self = .spring
        case "夏天":
            self = .summer
        case "秋天":
            self = .autumn
        case "冬天":
            self = .winter
        default:
            self = .spring
        }
    }

    var rawValue: String {
        switch self {
        case .spring :
            return "春天"

        case .summer :
            return "夏天"

        case .autumn :
            return "秋天"

        case .winter :
            return "冬天"
        }
    }
}

let s = Season.summer
print(s.rawValue)                       // 夏天
let s2 = Season.init(rawValue: "老天")
print(s2.rawValue)                      // 春天
```

### 关联枚举
前面2种枚举还不足以表现出枚举的强大性, swift中还允许枚举对象关联自定义的数据类型, 语法如下:

```swift
enum Province{
    case code(code: Int)
    case name(name: String)
}


print(MemoryLayout<Province>.size)              // 17
print(MemoryLayout<Province>.stride)            // 24
print(MemoryLayout<Province>.alignment)         // 8

let hubei_0 = Province.code(code: 42)           // 固定语法
let hubei_1 = Province.name(name: "湖北")
```

这种枚举叫作关联枚举, 即每个成员可以关联自定义的类型.  观察demo中枚举大小大致再结合前面枚举的底层编号, 大致可以推断关联枚举的内存布局:
1. 数据空间
2. 编号空间

在探究真正的内存布局前, 先来看c++中要实现这种功能要怎么做? 其实很简单使用struct和union就够了.

```cpp
typedef struct Province Province;
struct Province{
    // Constructor
    Province():Province(0){}
    Province(lb::uint8_t code):seq(EnumSequence::zero), code(code){}
    Province(const lb::string& name):seq(EnumSequence::one), name(new lb::string(name)){}

    // Destructor
    ~Province(){
        this->seq == EnumSequence::one ? (void)(delete this->name) : (void)0;
    }

    // Copy Structor
    Province(const Province& other){
        this->seq = other.seq;
        this->code = other.code;
        if(this->seq == EnumSequence::one){
            this->name = new lb::string(*other.name);
        }
    }

    // operator assign
    Province& operator =(const Province& other) {
        do {
            if(&other == this)
                break;

            // 不用检查 this->name == other.name两者的指针
            if(this->seq == EnumSequence::one){
                delete this->name;
                this->name = nullptr;
            }

            this->seq = other.seq;
            this->code = other.code;

            if(this->seq == EnumSequence::one){
                this->name = new lb::string(*other.name);
                break;
            }
        }while(0);

        return *this;
    }

private:
    enum class EnumSequence: uint8_t{
        zero,
        one,
    };
    union {
        lb::string* name;
        lb::uint8_t code;
    };
    EnumSequence seq;

}__attribute__((packed,aligned(sizeof(void*))));    // 指定对齐大小

int main(int args, char** argv){
    lb::cout << sizeof(Province) << lb::endl;           // 当前指针大小为8, 所以是8对齐, 实际Province的空间只用到了9字节, 但扩展为16
    auto p1 = Province(42);
    auto p2 = Province("湖北");
    p1 = p2;
    return 0;
}
```

上述必须在c++11后编译. 里面涉及到union, 对于union来说c++编译器无法给出默认的ctor, 因为union中的成员构造,复制构造,析构,赋值都无法统一, 所以必须由程序员来实现. 该demo只在说明swift中关联枚举的内存布局, 下面来看下在swift中真正的内存布局.

> 这里直接调用相关的api将内存打印出来, 不用特意去调试lldb

```swift
enum Test{
    case a(_ n1: Int, _ n2: Int, _ n3: Int)
    case b(_ n1: Int, _ n2: Int)
    case c(_ n1: Int)
    case d
}

print(MemoryLayout<Test>.size)          // 25, 对齐系数为1时, 即真正用的空间
print(MemoryLayout<Test>.stride)        // 32, 当前系统对齐时, 编译器分配的空间
print(MemoryLayout<Test>.alignment)     // 8,  当前系统对齐大小

var t1 = Test.a(0xa, 0xb, 0xc)          // t1 == Test.a. 关联的值为10,11,12
let t1_addr = withUnsafeMutablePointer(to: &t1, {UnsafeMutableRawPointer($0)})      // 获取地址


// 因为这里都是Int, 所以可以直接为系统的偏移量(其他类型的要自己计算)
let t1_addr_0_7 = t1_addr.load(fromByteOffset: 0, as: Int.self)                     // 依次按8字节读取内存
let t1_addr_8_15 = t1_addr.load(fromByteOffset: MemoryLayout<Int>.stride * 1, as: Int.self)
let t1_addr_16_23 = t1_addr.load(fromByteOffset: MemoryLayout<Int>.stride * 2, as: Int.self)
let t1_addr_24_32 = t1_addr.load(fromByteOffset: MemoryLayout<Int>.stride * 3, as: Int.self)

print(t1_addr_0_7, t1_addr_8_15, t1_addr_16_23, t1_addr_24_32)  // 10, 11, 12, 0    0表示枚举成员的编号

// 匹配到a
switch t1 {                 
case let .a(n1, n2, n3) :
    print("a:\(n1), \(n2), \(n3)")      // 打印

case let .b(n1, n2) :
    print("b:\(n1), \(n2)")

case let .c(n1) :
    print("c:\(n1)")

case .d :
    print("d")
}

// 通过内存修改第24到25字节(1个字节大小)的内存空间, 即修改序号为3(Test.d)
t1_addr.storeBytes(of: 3, toByteOffset: MemoryLayout<Int>.stride * 3, as: UInt.self)

switch t1 {
case let .a(n1, n2, n3) :
    print("a:\(n1), \(n2), \(n3)")

case let .b(n1, n2) :
    print("b:\(n1), \(n2)")

case let .c(n1) :
    print("c:\(n1)")

case .d :
    print("d")                          // 打印
}
```

通过上述测试关联枚举内存布局:
1. 取所有枚举成员中关联最大的空间
2. 以系统字节对齐
3. 最后的空间会存储枚举成员的序号

> 总之上述枚举内存布局算法和c++中stuct内联union一样


<a id="link-enum-memory-detail"></a>

### 关联枚举的内存细节
上小节中demo所举例的枚举很特殊, 即每个枚举成员所关联的内存结构是不一样的:
1. `a`关联3个Int
2. `b`关联2个Int
3. `c`关联1个Int
4. `d`无关联

swift中关联的枚举内存并不是这样简单, 它会将case成员进行分类, 每一类的编号是一样的, 同时再加以值域编号作区分:

```swift
enum Test {
    case no
    case da(a: Int)
    case ot
    case ab
    case ah(a: Int)
    case an(a: Int)
} 
```

上述枚举的大小还是16字节, 值域占据前8字节, 编号域占据第9个字节. 但枚举成员的内存不是简单的编号, 直接看汇编:

```swift
let no = Test.no
let da = Test.da(a: 0)
let ot = Test.ot
let ab = Test.ab
let ah = Test.ah(a: 0)
let an = Test.an(a: 0) 
```

```lua
swift`main:
    0x100003a78 <+0>:   adrp   x12, 5
    0x100003a7c <+4>:   adrp   x1, 5
    0x100003a80 <+8>:   add    x1, x1, #0x0              ; swift.no : swift.Test
                                                         ; x12 = &no
                                                         ; x1  = &no

    0x100003a84 <+12>:  adrp   x0, 5
    0x100003a88 <+16>:  adrp   x16, 5
    0x100003a8c <+20>:  add    x16, x16, #0x10           ; swift.da : swift.Test
                                                         ; x0  = &da - 16
                                                         ; x16 = &da

    0x100003a90 <+24>:  adrp   x17, 5
    0x100003a94 <+28>:  adrp   x14, 5
    0x100003a98 <+32>:  add    x14, x14, #0x20           ; swift.ot : swift.Test
                                                         ; x17 = &ot - 32
                                                         ; x14 = &ot
    0x100003a9c <+36>:  adrp   x15, 5
    0x100003aa0 <+40>:  adrp   x13, 5
    0x100003aa4 <+44>:  add    x13, x13, #0x30           ; swift.ab : swift.Test
                                                         ; x15 = &ab - 48
                                                         ; x13 = &ab
    0x100003aa8 <+48>:  adrp   x10, 5
    0x100003aac <+52>:  adrp   x11, 5
    0x100003ab0 <+56>:  add    x11, x11, #0x40           ; swift.ah : swift.Test
                                                         ; x10 = &ah - 64
                                                         ; x11 = &ah

    0x100003ab4 <+60>:  adrp   x8, 5
    0x100003ab8 <+64>:  adrp   x9, 5
    0x100003abc <+68>:  add    x9, x9, #0x50             ; swift.an : swift.Test
                                                         ; x8 = &an - 80
                                                         ; x9 = &an


    0x100003ac0 <+72>:  str    xzr, [x12]               ; *x12 = 0,         no.data = 0
    0x100003ac4 <+76>:  mov    w12, #0x3                ; w12 = 3, 32位操作, 但高32位被清零, 即x12 = 3
    0x100003ac8 <+80>:  strb   w12, [x1, #0x8]          ; *(x1 + 8) = 3,    no.seq   = 3

->  0x100003acc <+84>:  str    xzr, [x0, #0x10]         ; *(x0 + 16) = 0,   da.data = 0
    0x100003ad0 <+88>:  strb   wzr, [x16, #0x8]         ; *(x16 + 8) = 0,   da.seq  = 0

    0x100003ad4 <+92>:  mov    w16, #0x1                ; x16 = 1
    0x100003ad8 <+96>:  str    x16, [x17, #0x20]        ; *(x17 + 32) = 1,  ot.data = 1
    0x100003adc <+100>: strb   w12, [x14, #0x8]         ; *(x14 + 8) = 3,   ot.seq  = 3

    0x100003ae0 <+104>: mov    w14, #0x2                ; w14 = 2
    0x100003ae4 <+108>: str    x14, [x15, #0x30]        ; *(x15 + 48) = 2,  ab.data = 2
    0x100003ae8 <+112>: strb   w12, [x13, #0x8]         ; *(x13 + 8) = 3,   ab.seq  = 3

    0x100003aec <+116>: str    xzr, [x10, #0x40]        ; *(x10 + 64) = 0,  ah.data = 0
    0x100003af0 <+120>: mov    w10, #0x1                ; w10 = 1
    0x100003af4 <+124>: strb   w10, [x11, #0x8]         ; *(x11 + 8) = 1,   ah.seq  = 1

    0x100003af8 <+128>: str    xzr, [x8, #0x50]         ; *(x8 + 80) = 0    an.data = 0
    0x100003afc <+132>: mov    w8, #0x2                 ; w8 = 2
    0x100003b00 <+136>: strb   w8, [x9, #0x8]           ; *(x9 + 8) = 2     an.seq  = 2
    0x100003b04 <+140>: mov    w0, #0x0
    0x100003b08 <+144>: ret    
```

整理一下:

|对象|关联|值域|编号|
|:-|:-|:-|:-|
|no|无|0|3|
|da|`(Int)`|0|0|
|ot|无|1|3|
|ab|无|2|3|
|ah|`(Int)`|0|1|
|an|`(Int)`|0|2|

很明显swift对关联枚举中某类成员进行了分类:
1. 没有类型的枚举成员分成了一类, 它们具有相同的编号, 但又借助共享的值域进行第2次编号的区分
2. 其他有关联值的枚举成员只通过编号区分
3. swift中会将没有关联的枚举成员编号排到最后. 如no,ot,ab的编号3是最小的

这个很关键, 因为后续在探究可选项可选操作时要用到这些东西

### 关联枚举成员字符串化
和原始枚举一样, 当遵循了`CustomStringConvertible`返回用户自定义的字符串, 当未提供时也会用metadata. 
```swift
enum Province: CustomStringConvertible{
    case code(code: Int)
    case name(name: String)

    var description: String {
        switch self {
        case .code(let c) :
            return "编码:\(c)"

        case .name(let name) :
            return "省名:\(name)"
        }
    }
}

let str = String(describing: Province.name(name: "湖北")) // 省名:湖北 
```

当未遵循该协议时,则整个过程就很复杂, 但和[前面](#link-enum-string)的过程一样的, 只是在第5步, 为了说明问题, 笔者这里将源码贴出来:

```swift
// _adHocPrint_unlocked 函数中关联枚举部分的代码
case .enum:
    if let cString = _getEnumCaseName(value),                       // 去cpp中通过metadata获取枚举成员的C字符串
        let caseName = String(validatingCString: cString) {         // 转换成Swift.String

        // 调试模式下的字符串显示
        if isDebugPrint {                                           // 由前面的函数传递过来的为false
            printTypeName(mirror.subjectType)                       
            target.write(".")
        }

        target.write(caseName)                                      // target是前面创建的字符串

    } else {                                                        // 这里源码中这样解释的: 枚举可能是c++中的枚举, 这种枚举没有metadata, 然后尝试是否可获取到原始值
        printTypeName(mirror.subjectType)
        if let rawValue = _fallbackEnumRawValue(value) {
            target.write("(rawValue: ")
            _debugPrint_unlocked(rawValue, &target);
            target.write(")")
        }
    }

    // mirror是前面通过Province.name("name":"湖北")这个传入的值以及Province这个类型所构造出来的Metadata引用
    // 获取到CaseName后, 查看一下当前枚举成员的metadata中是否有子成员
    if let (_, value) = mirror.children.first {     
        if Mirror(reflecting: value).displayStyle == .tuple {       // __code_org_display
            _debugPrint_unlocked(value, &target)
        } else {
            target.write("(")                                   // 代码中枚举成员的字符串化发生在这一步
            _debugPrint_unlocked(value, &target)                    // __code_org_str_enum_mem_value
            target.write(")")
        }
    }
```

通过上述源码, 可以直接在swift中作一些测试:

```swift
var m = Mirror.init(reflecting: Province.name(name: "hubei"))

switch m.displayStyle {                     // 对应源码中 __code_org_display
case .tuple:
    print("tuple")          
default:
    print("no tuple")                       // 这个
}

if let t = m.children.first {
    print(t.label!)                         // 对应__code_org_str_enum_mem_value, 不带左右括号的
    print(t.value)
}

#if false
no tuple
name
(name: "hubei")
#endif
```

关于String等swift的标准库类型, 以及metadata这部分的内容将在后面具体的章节详细探究


### 关联枚举case下的穿透
swift建议在case中不要使用fallthrough, 但某些业务下使用穿透可能更好, 如下面的案例
```swift
enum 座飞机 {
    case 会员(Double)
    case 普通乘客
}

switch 座飞机.会员(Double((0...10000).randomElement()!)) {
case .会员(let money) where (5000...).contains(money):
    print("超级仓或")
    fallthrough
case .会员(let money) where (2000...).contains(money):
    print("高级仓或")
    fallthrough
case .普通乘客:
    print("经济仓")
default:
    break
}
```

demo中根据会员余额越高, 所享受的待遇越多. 



### 递归枚举
由于关联枚举可以关联任何类型, 当出现关联值就是当前枚举时就是递归枚举

```swift
enum Operator{
    typealias Element = Int
    case data(_ data: Element)
    indirect case sum(_ d1: Operator, _ d2: Operator)
    indirect case ava(_ d1: Operator, _ d2: Operator)

    func exec() -> Element {
        switch self {
        case .data(let n) :
            return n

        case let .sum(n1, n2) :
            return n1.exec() + n2.exec()

        case let .ava(n1, n2) :
            return Self.sum(n1, n2).exec() / 2
        }
    }
}

let n1 = Operator.data(20)                  // 数据
let n2 = Operator.data(40)                  // 数据

let sum = Operator.sum(n1, n2)              // 加操作
let ava = Operator.ava(n1, n2)              // 平均操作

print(n1.exec())                            // 直接返回数据 20
print(n2.exec())                            // 直接返回数据 40
print(sum.exec())                           // 内部相加 60
print(ava.exec())                           // 内部相加除以2 30
```
这种递归枚举要自己好好体会


<a id="link-enum-option"></a>

### 泛型枚举
swfit中枚举可以定义泛型

```swift
enum Wrap<T> : CustomStringConvertible, ExpressibleByNilLiteral{
    case null
    case wrap(_ data: T)

    var description: String {
        switch self {
        case .null :
            return "nil"
        case .wrap(let data) :
            return "Wrap(\(data))"
        }
    }

    init(nilLiteral: ()) {
        self = .null
    }

    init(_ data: T) {
        self = .wrap(data)
    }
}

print(Wrap<String>("hello"))           

let world = Wrap("world")
print(world)
let Nil = Wrap<String>.null
print(Nil)
let null:Wrap<String> = nil             // 因为遵循了 ExpressibleByNilLiteral 所以可以直接使用字面量nil赋值
print(null) 
```

上述使用枚举包装了类型, 当没有值时使用成员`.null`标记, 这个是可选项的基本原理, 下章节将学习可选


[^ann-enum-raw]: 在后续的property章节将会学习到
</font>
