<font size = 4>

### 函数嵌套再提
在第7章函数中简单提及了一下嵌套函数, 因为嵌套函数中会涉及局部对象的内存管理, 所以当时并未过多展开, 在当前小节笔者还是不会展开, 这会放到本章的后续章节. 现在先来回顾函数的嵌套, 即可以在函数中定义函数

<a id="link-func-nested"></a>

```swift
extension IntegerLiteralType {
    enum oper{
        case add, sub, mul, div
    }
    func operations(op: Self.oper) -> (Self) -> Self{
        func add(_ other: Self) -> Self{self + other}
        func sub(_ other: Self) -> Self{self - other}
        func mul(_ other: Self) -> Self{self * other}
        func div(_ other: Self) -> Self{self / other}

        switch op {
        case .add:
            return add
        case .sub:
            return sub
        case .mul:
            return mul
        case .div:
            return div

        @unknown default:
            fatalError("不合法的操作")
        }
    }
}

// -3
let n = 2.operations(op: .sub)(5)
```

该demo扩展了整型字面量方法, 这一点先不用关心. 在方法operations内部定义了4个函数, 它会根据当前的枚举值来返回对应的函数到外界, 外界拿到该函数时可以直接调用. 这个是形式上最简单的嵌套函数的使用事例. 


### 函数类型
在前一小节的例子中, 函数直接被当作了另一个函数的返回值, 事实上从编译器的角度来看, 所有的函数:
1. 全局函数
2. 函数内部的嵌套函数
3. 成员方法
4. 类型方法
5. 计算属性
6. 下标
7. 闭包表达式

其实都是一样的, 编译器最终会将它们整合到可执行文件的代码段中. 只不过在编译期书写格式不同, 当然这里面会牵扯到内存管理, 后续小节再说了. 这些不同格式的函数在swift中其实都有自己的类型, 统称为<font color = red>函数类型</font>,  所以这里面就有2层含义:
1. 可以直接定义该类型的对象, 这些对象可以引用到这些函数
2. 函数的参数及返回值可以是函数类型, 可以直接传递函数类型的对象. 
    - 当然swift中若直接传递这些函数的本身, 编译器将会做好类型转换

除了计算属性以及下标之外都, 其他可以定义成明显的类型. 

> <font size = 6>埋点1</font>: 
> 
> <font color = red>计算属性和下标可以通过KeyPath形式来引用, 这个将在属性章节学习到</font>

```swift
func test(_ value: Int){
    print("global test(int)")
}
func test(_ value: Double){
    print("global test(double)")
}
struct T{
    static func test(_ value: Int){
        print("static T test(int)")
    }
    func test(_ value: Int){
        print("instance T test(int)")
    }
}


let f1:(Int) -> Void = test             // (Int) -> ()
let f2:(Double) -> Void = test          // (Double) -> ()
let f3:(Int) -> Void = T.test           // T.test ==> (Int) -> ()
let f4:(T)->(Int) -> Void = T.test      // T.test ==> (Int) -> ()


f1(20)
f2(20)
f3(20)
f4(T())(20) 

#if false
global test(int)
global test(double)
static T test(int)
instance T test(int)
#endif
```

[前面](#link-func-nested)的案例中要做一次add, 必须调用2次函数:
1. 获取真正的add函数
2. 调用add做相加

这2步的操作是针对外界来说的, 从使用的角度来看, add的操作丧失了灵活性, 它只是单纯的加另一个整数数值. 如果后续业务更改导致add的操作不再是简单的加other, 则程序就是不健壮的, 从这一点考虑, add的操作应该由外界来指定, 此刻应该考虑传递函数类型, 由内部回调 

<a id="link-demo-1"></a>

```swift
extension IntegerLiteralType {
    func add(val: Self,  impl : (Self, Self) -> Self) -> Self{
        impl(self, val)
    }

    func sub(val: Self,  impl : (Self, Self) -> Self) -> Self{
        impl(self, val)
    }
}

func add_op(_ one: IntegerLiteralType, _ two: IntegerLiteralType) -> Int{
    one + two
}

func sub_op(_ one: IntegerLiteralType, _ two: IntegerLiteralType) -> Int{
    one - two
}

// 4
print(2.add(val: 2, impl: add_op))

// 2
print(2.sub(val: 2, impl: sub_op))
```
在add或sub函数的内部将直接调用外界传递的`add_op`或`sub_op`, 从业务的角度来看add是最初的业务功能, 后续可以提供不同的业务实现(<font color = red>传递不同的函数</font>), 而原来业务的流程并不发生变化. 

回到测试, 当向add函数传递函数名`add_sub`时, swift实际会将函数转换为函数类型, 以便参数接收. 在swift中除了可以传递函数名给函数类型外, 也可以传递一个匿名函数. 匿名函数本身也是函数, 它也对应着函数类型, 只不过没有名字. 匿名函数在swift中被称为闭包表达式.


### 闭包表达式
上一小节引导出了闭包表达式的概念, 这种概念在其他编程语言中也有所体现:
1. OC的block
2. c++中的lambda

后续笔者将以lambda来简称闭包表达式, swift中lambda的语法格式如下

```txt
{
    (参数列表) -> 返回值类型 in 

    函数体
}
```

需要注意:
1. 参数不能有默认值
2. 参数不能有别名
3. 调用时不能指定参数名
4. 抛开前面的, 其他和函数一样

```swift
let lambda = {
    (v1: Int, v2: Int) -> Int in
    v1 + v2 // 只有1条语句时, 直接当作返回值
}

lambda(v1: 20, v2: 20)


let lambda1 = {
    (v1: Int, v2: Int = 20) -> Int in
    v1 + v2
}

let lambda2 = {
    (arg_1 v1: Int, v2: Int) -> Int in
    v1 + v2
} 
```

将[demo](#link-demo-1)修改成lambda如下:

```swift
// 4
print(2.add(val: 2, impl: { (v1: Int, v2: Int) -> Int in
    v1 + v2
}))


// 0
print(2.sub(val: 2, impl: { (v1: Int, v2: Int) -> Int in
    v1 - v2
}))
```

在使用lambda时要注意:lambda没有对象接收时,不能在全局区定义
> 其实可以在全局区忽略lambda

```swift
{
    (v1: Int, v2: Int = 20) -> Int in
    v1 + v2
}       // error 没有对象接收, 不能定义在全局区


do {
    {
        (v1: Int, v2: Int = 20) -> Int in
        v1 + v2
    }
} // 没有问题, lambda定义在局部区域


_ =  {
    (v1: Int, v2: Int = 20) -> Int in
    v1 + v2
}   // 直接在全局区忽略了lambda
```

### lambda的简写规则
lambda可以在书写上做到很大的简化:
1. 函数头部声明区域
2. 省略return关键字
3. 直接传递操作符(<font color = red>实际操作符就是函数</font>)
4. 尾随lambda
5. 特殊lambda的编译器优化(<font color = red>桥接</font>)
    1. 自动闭包
    2. KeyPath
6. 如果一个函数中所有的参数都lambda, 则可以都简写成尾随闭包


后面笔者以Array相关的方法为例:

```swift
// 参数是一个lambda, 类型是 (E) -> T
//  整个函数的返回值是 [T]
@inlinable public func map<T, E>(_ transform: (Element) throws(E) -> T) throws(E) -> [T] where E : Error 

// 参数是一个lambda, 类型是 (E, E) -> Bool
@inlinable public mutating func sort(by areInIncreasingOrder: (Element, Element) throws -> Bool) rethrows
```

对于第1条规则, 是利用编译器的类型推导, 原则上就是编译器可以通过上下文环境推导出函数的签名则就可以最大程度上省略lambda中的函数声明部分:

```swift
let n = [2, 3, 4]

// 全写
let power_arry = n.map<Int, Int>{ (a: Int) -> Int in
    return a * a
}
print(new_arry)  // [4, 9, 16]


// 省略了参数的类型
// 由于n.E = Int
//  所以map的参数类型必定为:(Int) -> T
//  所以在定义lambda时可以省略参数的类型
//  但现在T无法确定, 但lambda在声明时指定了返回Int
//  所以编译器可以确定map参数的类型就是(Int) -> Int
_ = n.map({ a -> Int in
    return a * a
})


// 省略了参数的类型和返回值
//  返回值可以通过lambda中的执行体推导出来
_ = n.map({ a in
    return a * a
})


// 省略了函数声明的部分, 只有函数体
//  由于参数的类型和返回都可以省略,
//  swift就琐碎规定不再需要整个函数的声明,
//  然后以$0, $1, $2, ... 的格式在lambda的执行体中引用对应的参数
_ = n.map({ return $0 * $0})
```

> lambda的实现中没有任何地方访问到`$0`参数是不允许的, 此刻必须声明忽略参数

```swift
// lambda中没有用到 $0
//  必须有函数的声明, 并将参数设置为 _ 以表示忽略
_ = n.map({_ in return 9})
```

对于第2条: 当lambda的实现只有1条语句时, 可以直接省略return这个关键字, 所以上述可以简化成:

```swift
_ = n.map({$0 * $0})
```

> 这其实是从函数那边继承过来的规则


对于第3条: 实际上传递的是函数名

```swift
// Int的操作符重载, 实际上它是一个函数 (Int, Int) -> Bool
//  也就是说在上下文成立的情况下, > 就是一个函数
public static func > (lhs: Int, rhs: Int) -> Bool



var n = [2, 3, 4]

// 这里在书写格式上写了一个 > 
// 实际在编译器会根据当前上下文推导出 > 是 Int的操作重载的那个函数
n.sort(by: >)
```

对于第4条: 当一个函数的最后1个参数是lambda时, 可以以以下方式调用:

```swift
// lambda是sort函数的最后一个参数:
//  省略参数标签
//  将lambda提出到括号之后书写(原来的规则是不变的)
n.sort(){$0 > $1} 


//  lambda是sort函数的唯一参数, 可以直接省略括号
n.sort {$0 > $1} 
```

> lambda一定是唯一参数的情况下可以省略调用函数的括号, 其他情况在调用格式上一致时也可以省略

```swift
// test函数有2个参数, lambda是尾随闭包
func test(_ a: Int = 20, by: (Int, Int) -> Bool){}

// 调用时若不传递第1个参数, 可以省略小括号
test{$0 > $1}
```

对于第5条下的自动闭包:
1. lambda的类型必须为`()->E`

```swift
// 使用关键字 @autoclosure修饰 固定的lambda
func M_I_N(_ flag: Bool = false, by: @autoclosure () -> Int) -> Int{
    flag ? 0 :  by()
}

// 传递参数时20被编译器转换为 {_ in 20}
print(M_I_N(by: 20)) 
```

对于第5条下的KeyPath, 笔者在这里先简单给出范例(<font color = red>KeyPath后续会学习的</font>)

```swift
struct T{
    let name: String
    init(name: String) {
        self.name = name
    }
}

// 定义了一个Path
//  有一个只读的类型计算属性
//  类型是KeyPath<Person,T>
protocol Path{
    static var path: KeyPath<Person,T> {get}
}

struct Person : Path{

    // Person遵循了Path, 则必须实现类型计算属性的getter或getter,setter
    //  这里只实现了getter, 编译器在当前的上下文中将
    // \.name 转换成了KeyPath<Person,T>类型的对象然后返回
    static var path: KeyPath<Person, T> {\.name} // getter方法

    let name: T

    init(name: T) {
        self.name = name
    }

    init(name: String){
        self.init(name: T(name: name))
    }
}

// map的参数lambda要求的类型是 (Person) -> T
//  但传递给map的是一个 字面量书写的 \.name
//  实际上它是一个简写, 全写为 \Person.name
//  在swift中这是一种字面量, 格式是固定的, 编译器看到它后
//  在不同的上下文中转换的类型就不同. 
//  在当前map调用的上下文中, 编译器会将 \.name 转换成 {($0:Person) -> T in $0.name}
let result1 = [Person(name: "tierry"), Person(name: "jerry"), Person(name: "tom"), Person(name: "kitty")].map(\.name)

// 这里直接报错, 因为向map提供的参数不是字面量 \.name , 
//  实际传递的类型是KeyPath<Person,T>, Array的所有成员方法中没有map(KeyPath<Person, T>)这种格式
// let result2 = [Person(name: "tierry"), Person(name: "jerry"), Person(name: "tom"), Person(name: "kitty")].map(Person.path)
print(result1)

#if false
[swift.T(name: "tierry"), swift.T(name: "jerry"), swift.T(name: "tom"), swift.T(name: "kitty")]
#endif
```

对于第6条: 如果函数中所有的参数都是lambda, 则都可以写成尾随闭包(<font color = red>高版本的swift支持</font>)

```swift
func test(_ a: () -> (), _ b: () -> (), last: (Int) -> Bool){

}
test {

} _: {

} last: {
    $0 == 0
} 
```


### 内存管理
因为函数的嵌套以及lambda的存在, 那么就可能出现: 嵌套函数或lambda中引用外层函数的局部对象时所引发的局部对象的内存问题, 大致2种场景:
1. 当外层函数的调用栈未结束时, 此刻不用考虑局部对象的内存释放
2. 当外层函数的调用栈已经被销毁, 但后续嵌套函数或lambda被执行, 则逻辑上一定出现非法内存访问

> PS: 为了简单说明这种情况, 笔者叙述的是嵌套函数或lambda引用了外层的局部对象, 实际上只要它们引用了函数调用栈中的局部对象, 都可能出现非法内存访问.

在探究这个问题前, 先来看一下函数类型对象的本质

```swift
func test(n: Int) -> Int {
    n + n
}

var f = test

let f2 = f 
```

```lua
swift`main:
    0x100003ea8 <+0>:   sub    sp, sp, #0x50
    0x100003eac <+4>:   stp    x29, x30, [sp, #0x40]
    0x100003eb0 <+8>:   add    x29, sp, #0x40
    0x100003eb4 <+12>:  adrp   x9, 5                    ; x9 = &f
    0x100003eb8 <+16>:  str    x9, [sp]                 ; *sp = &f
    0x100003ebc <+20>:  adrp   x0, 5                    ; x0 = &f
    0x100003ec0 <+24>:  add    x0, x0, #0x0             ; swift.f : (Swift.Int) -> Swift.Int
    0x100003ec4 <+28>:  str    x0, [sp, #0x8]           ; *(sp + 8) = &f
->  0x100003ec8 <+32>:  adrp   x8, 0                    
    0x100003ecc <+36>:  add    x8, x8, #0xf40           ; swift.test(n: Swift.Int) -> Swift.Int at main.swift:8
                                                        ; x8 = test 函数地址

    0x100003ed0 <+40>:  str    x8, [x9]                 ; *x9 = x8 ==> f<0~7> = test地址
    0x100003ed4 <+44>:  mov    x3, #0x0                 ; x3 = 0 
    0x100003ed8 <+48>:  str    xzr, [x0, #0x8]          ; *(x0 + 8) = 0 ==> f<8~15> = 0
                                                        ;   因为事先测试了函数类型的大小, f的大小是16
                                                        ;   前8字节是函数地址
                                                        ;   后8字节目前清零

    0x100003edc <+52>:  sub    x1, x29, #0x18           ; x1 = x29 - 0x18, 局部对象的地址
    0x100003ee0 <+56>:  str    x1, [sp, #0x10]          ; *(sp + 0x10) = x1
    0x100003ee4 <+60>:  mov    w8, #0x20                ; w8 = 32 
    0x100003ee8 <+64>:  mov    x2, x8                   ; x2 = x8 ==> x2 = 标记(读)
    0x100003eec <+68>:  bl     0x100003f70              ; symbol stub for: swift_beginAccess
                                                        ; 这里要访问全局对象f, 为了内存的写独占, 所以调用该方法
                                                        ;   x0: &f
                                                        ;   x1: &local-tmp
                                                        ;   x2: 32(读)
                                                        ;   x3: 0
    0x100003ef0 <+72>:  ldr    x9, [sp]                 ; x9 = *sp = &f
    0x100003ef4 <+76>:  ldr    x8, [sp, #0x8]           ; x8 = *(sp + 8) = &f
    0x100003ef8 <+80>:  ldr    x9, [x9]                 ; x9 = *&f ==> x9 = f<0~7> test地址
    0x100003efc <+84>:  str    x9, [sp, #0x18]          ; *(sp + 0x18) = test地址
    0x100003f00 <+88>:  ldr    x0, [x8, #0x8]           ; x0 = *(x8 + 8) = f<8~15>, 后8字节的数据, 为0
                                                        ;   相当于调用 retain时传递了空指针, 内部将直接返回
                                                           
    0x100003f04 <+92>:  str    x0, [sp, #0x20]          ; *(sp + 0x20) = f<8~15>
    0x100003f08 <+96>:  bl     0x100003f88              ; symbol stub for: swift_retain
                                                        ;   很明显这里在对f2对象做retain操作
                                                        ;   从这里也可以看出函数类型似乎像是heap对象.
                                                        ;   但其实不是, 因为f的地址在全局区, 这里只是
                                                        ;   f的大小是16字节, 前8字节是函数, 后8字节是引用计数

    0x100003f0c <+100>: ldr    x0, [sp, #0x10]          ; x0 = *(sp + 0x10) = 局部对象的地址
    0x100003f10 <+104>: ldr    x10, [sp, #0x18]         ; x10= *(sp + 0x18) = test地址
    0x100003f14 <+108>: ldr    x8, [sp, #0x20]          ; x8 = *(sp + 0x20) = f<8~15>, 引用计数(0)
    0x100003f18 <+112>: adrp   x11, 5                   ; x11 = &f
    0x100003f1c <+116>: adrp   x9, 5                    ; x9 = &f
    0x100003f20 <+120>: add    x9, x9, #0x10            ; swift.f2 : (Swift.Int) -> Swift.Int
                                                        ;   偏移16字节后就是f2的地址

    0x100003f24 <+124>: str    x10, [x11, #0x10]        ; *(x11 + 0x10) = x10 ==> *&f2 = test ==> f2<0~7> = test地址
    0x100003f28 <+128>: str    x8, [x9, #0x8]           ; *(x9 + 8) = x8 ==> 引用计数(0)
                                                        ;   这里的引用计数没有任何安全可言,

    0x100003f2c <+132>: bl     0x100003f7c              ; symbol stub for: swift_endAccess
    0x100003f30 <+136>: mov    w0, #0x0                 ; =0 
    0x100003f34 <+140>: ldp    x29, x30, [sp, #0x40]
    0x100003f38 <+144>: add    sp, sp, #0x50
    0x100003f3c <+148>: ret  
```

通过汇编测试可以发现, swift中的函数类型至少占据16字节的空间, 前8字节是函数的地址, 后8字节是引用计数(<font color = red>再挖堀一点就是该区域是heap内存</font>). 在当前测试中f所关联的实体是具体的函数, 而函数本身(不论什么类型的函数)会一直运行于整个进程的生命中, 所以就目前来看使用引用计数的意义显得多余. 那为什么还要设计出引用计数这一部分呢?


现在回到最开始所提到的, 当函数内部引用了外围的局部对象, 在某些场景下需要对该局部对象的内存做管理. 典型的情况就是外围的函数已经结束, 然后再调用内部嵌套的函数, 此刻局部对象已经被销毁了

```swift
func test() -> (Int) -> Int{
    var n = 20
    return {
        (left: n += $0, right: n).right
    }
}

let lambda = test() // 当这句代码执行完毕后, test函数中的
                        // 局部对象n已经被销毁


// 此刻局部对象的n已经被销毁, 调用lambda后
//  lambda的内部会访问到n对象的内存, 理论上应该是不对的
let result = lambda(30) // __code_right_or_wrong
```

测试中的`__code_right_or_wrong`到底会不会报错呢? 事实是他并不会报错!!  那编译器是怎么处理的呢? 如果笔者是编译器的作者, 解决方案的原则是不要销毁局部对象n的内存, 理论上就是要延迟n的生命周期, 只要做到这个效果就行了. 

一种实现方案是:将n的内存拷贝到heap中, 然后lambda的内部访问这个heap的内存, 当不再需要lambda时再将heap中的n释放掉. 其实这是一种常见的解决方案, 只不过它依赖于系统函数, 因为合格的编译器应该是在语言层面上解决这种问题, 所以它应该直接系统调用开辟内存来复制n. 但现在绝大部分编译器的实现都配合了自己的标准库, 所以基本上都是调用自己语言的库函数来分配空间复制n. swift也不例外. 

在看具体的汇编之前, 笔者这里先来推测一下lambda的内存结构, 然后再写代码测试推测是不是对的, 最后再看汇编.  

根据前面测试函数类型的内存空间可以推测: 后8字节的空间其实就是记录是否引用了局部对象. 前面测试的test函数内部未引用任何局部对象, 所以后8字节是空的, 基于此来推测当嵌套函数或lambda内部引用了局部对象时的内存结构:
1. 值类型的对象tmp, 大小是16字节(<font color = red>只引用了1个局部对象的情况</font>)
2. `tmp<0~7>`存储具体的实现地址
3. `tmp<8~15>`heap指针, 指向的空间为8字节, 内容是局部对象n的值
4. 逻辑上当以函数类型的对象ptr接收lambda或嵌套函数时, 该对象在生命周期结束后, swift应该对`tmp<8~15>`做release操作
5. 同样的再次引用时ptr时, 应该对`tmp<8~15>`做retain操作


```swift
func test() -> (Int) -> Int{
    var n = 20
    return {
        n += $0
        return n
    }
}

struct Heap{
    let meta, counting: Int
}

struct T {
    let addr: UInt64
    let heap: UInt
    init(addr: UInt64, heap: UInt) {
        self.addr = addr
        self.heap = heap
    }
}
do{
    var lambda = test()
    var lam = lambda
    let ptr : UnsafeRawPointer = .init(&lambda)
    let obj = ptr.bindMemory(to: T.self, capacity: 1)

    let addr = obj.pointee.addr     // __code_func_addr

    let heap_addr = obj.pointee.heap

    // heap.pointee.counting = 3, 引用计数
    let heap: UnsafePointer<Heap>! = .init(bitPattern: heap_addr)
}
```

通过测试后8字节确实是堆空间(<font color = red>swift开辟空间来复制局部对象n</font>), 测试中给出了引用计数, 但前8字节并不是test的函数地址, 这里只能通过汇编来看了, 汇编对应的测试源码如下:

```swift
func test() -> (Int) -> Int{
    var n = 20
    return {
        n += $0
        return n
    }
}

var lambda = test()
var f = lambda

f(20)
```
 

```lua
swift`test():
    0x100003dd8 <+0>:   sub    sp, sp, #0x20
    0x100003ddc <+4>:   stp    x29, x30, [sp, #0x10]
    0x100003de0 <+8>:   add    x29, sp, #0x10
    0x100003de4 <+12>:  str    xzr, [sp, #0x8]          ; *(sp + 8) = 0
    0x100003de8 <+16>:  adrp   x8, 1                     
    0x100003dec <+20>:  add    x8, x8, #0x30
    0x100003df0 <+24>:  add    x0, x8, #0x10            ; x0 = $Int.metadata
    0x100003df4 <+28>:  mov    w8, #0x18                ; w8 = 24 
    0x100003df8 <+32>:  mov    x1, x8                   ; x1 = 24
    0x100003dfc <+36>:  mov    w8, #0x7                 ; w8 = 7 
    0x100003e00 <+40>:  mov    x2, x8                   ; x2 = 7
    0x100003e04 <+44>:  bl     0x100003f30              ; symbol stub for: swift_allocObject
                                                        ;   x0 = &heap-n 
                                                        ;   heap-n<0~7> = &Int.metadata
                                                        ;   heap-n<8~15> = 0x3(初始化的引用计数)
    0x100003e08 <+48>:  str    x0, [sp]                 ; *sp = &heap-n
    0x100003e0c <+52>:  add    x8, x0, #0x10            ; x8 = x0 + 16 ==> x8 = &heap-n.data
    0x100003e10 <+56>:  str    x8, [sp, #0x8]           ; *(sp + 8) = &heap-n.data
    0x100003e14 <+60>:  mov    w8, #0x14                ; w8 = 20 
    0x100003e18 <+64>:  str    x8, [x0, #0x10]          ; *(x0 + 16) = 20 ==> heap-n.data = 20
                                                        ;   复制局部对象n的值到heap中

->  0x100003e1c <+68>:  bl     0x100003f6c              ; symbol stub for: swift_retain
                                                        ;   heap-n<7~15> = 0x2_00_00_00_03

    0x100003e20 <+72>:  ldr    x0, [sp]                 ; x0 = *sp ==> &heap-n
    0x100003e24 <+76>:  bl     0x100003f60              ; symbol stub for: swift_release
                                                        ;   heap-n<7~15> = 0x3
                                                    
                                                    ; test函数的局部对象n实际在编译器的过程变成了
                                                    ;   *(sp + 8){&heap-n.data}
                                                    ;
                                                    ;   PS: 也就是说编译器发现了lambda引用了局部对象
                                                    ;   后, 在幕后将这个所谓的局部对象做成了堆空间
                                                    ;   的对象, 只是在代码层面还是当作Int在使用罢了.
                                                    ;   这里还可能是编译器发现test函数将返回lambda,
                                                    ;   返回的这个lambda将构成闭包环境, 所以基于这个
                                                    ;   原因编译器才会转换局部对象n为heap-n

    0x100003e28 <+80>:  ldr    x1, [sp]                 ; x1 = *sp = &heap-n
    0x100003e2c <+84>:  adrp   x0, 0                    ; x0 = 0
    0x100003e30 <+88>:  add    x0, x0, #0xf28           ; partial apply forwarder for closure #1 (Swift.Int) -> Swift.Int in swift.test() -> (Swift.Int) -> Swift.Int at <compiler-generated>
                                                        ;   x0 = tmp-func, 这个地址并不是test函数的地址
                                                        ;   从这里可以看出swift并不是直接将闭包中的实现地址反馈到外界
                                                        ;   而是包装了一层, 外界调用时先进入到 tmp-func内, 这个函数内部再调用test

    0x100003e34 <+92>:  ldp    x29, x30, [sp, #0x10]
    0x100003e38 <+96>:  add    sp, sp, #0x20
    0x100003e3c <+100>: ret 

swift`main:
    0x100003cd0 <+0>:   sub    sp, sp, #0xb0
    0x100003cd4 <+4>:   stp    x20, x19, [sp, #0x90]
    0x100003cd8 <+8>:   stp    x29, x30, [sp, #0xa0]
    0x100003cdc <+12>:  add    x29, sp, #0xa0           
    0x100003ce0 <+16>:  bl     0x100003dd8              ; swift.test() -> (Swift.Int) -> Swift.Int at main.swift:27
->  0x100003ce4 <+20>:  mov    x8, x0                   ;   x8 = tmp-func
    0x100003ce8 <+24>:  adrp   x9, 5                    ; x9 = &lambda(全局对象)
    0x100003cec <+28>:  str    x9, [sp]                 ; *sp = &lambda
    0x100003cf0 <+32>:  adrp   x0, 5                    
    0x100003cf4 <+36>:  add    x0, x0, #0x0             ; swift.lambda : (Swift.Int) -> Swift.Int
                                                        ;   x0 = &lambda
    0x100003cf8 <+40>:  str    x0, [sp, #0x8]           ; *(sp + 8) = &lambda
    0x100003cfc <+44>:  str    x8, [x9]                 ; *x9 = x8 ==> lambda<0~7> = tmp-func
    0x100003d00 <+48>:  str    x1, [x0, #0x8]           ; *(x0 + 8) = x1 ==> lambda<8~15> = &heap-n
                                                        ; 全局对象lambda的前8字节是实现地址
                                                        ;   后8字节是引用的局部对象n的堆空间地址

    0x100003d04 <+52>:  sub    x1, x29, #0x28           ; x1 = &tmp-local-0
    0x100003d08 <+56>:  str    x1, [sp, #0x10]          ; *(sp + 16) = &tmp-local-0
    0x100003d0c <+60>:  mov    w8, #0x20                ; w8 = 32 
    0x100003d10 <+64>:  mov    x2, x8                   ; x2 = 32(读操作), 访问全局对象的准备工作
    0x100003d14 <+68>:  str    x2, [sp, #0x28]          ; *(sp + 0x28) = 32
    0x100003d18 <+72>:  mov    x3, #0x0                 ; x3 = 0 
    0x100003d1c <+76>:  str    x3, [sp, #0x30]          ; *(sp + 0x30) = 0
    0x100003d20 <+80>:  bl     0x100003f3c              ; symbol stub for: swift_beginAccess
                                                        ;   x0: &lambda
                                                        ;   x1: &tmp-local-0
                                                        ;   x2: 32(读操作)
                                                        ;   x3: 0

    0x100003d24 <+84>:  ldr    x9, [sp]                 ; x9 = *sp = &lambda
    0x100003d28 <+88>:  ldr    x8, [sp, #0x8]           ; x8 = *(sp + 8) = &lambda
    0x100003d2c <+92>:  ldr    x9, [x9]                 ; x9 = lambda<0~7> = tmp-func
    0x100003d30 <+96>:  str    x9, [sp, #0x18]          ; *(sp + 24) = tmp-func
    0x100003d34 <+100>: ldr    x0, [x8, #0x8]           ; x0 = *(x8 + 8) = lambda<8~15> = &heap-n
    0x100003d38 <+104>: str    x0, [sp, #0x20]          ; *(sp + 0x20) = &heap-n
    0x100003d3c <+108>: bl     0x100003f6c              ; symbol stub for: swift_retain
                                                        ;   heap-n<8~15> = 0x2_00_00_00_03

    0x100003d40 <+112>: ldr    x0, [sp, #0x10]          ; x0 = *(sp + 16) = &tmp-local-0
    0x100003d44 <+116>: ldr    x10, [sp, #0x18]         ; x10 = *(sp + 24) = tmp-func
    0x100003d48 <+120>: ldr    x8, [sp, #0x20]          ; x8 = *(sp + 0x20) = &heap-n
    0x100003d4c <+124>: adrp   x11, 5       
    0x100003d50 <+128>: str    x11, [sp, #0x38]         
    0x100003d54 <+132>: adrp   x9, 5
    0x100003d58 <+136>: add    x9, x9, #0x10            ; swift.f : (Swift.Int) -> Swift.Int
                                                        ; x9 = &f(全局对象), x11 = &f - 0x10
    0x100003d5c <+140>: str    x9, [sp, #0x40]          ; *(sp + 0x40) = &f
    0x100003d60 <+144>: str    x10, [x11, #0x10]        ; *(x11 + 0x10) = x10 = tmp-func
    0x100003d64 <+148>: str    x8, [x9, #0x8]           ; *(x9 + 8) = &heap-n
                                                        ;   这2条指令实际上是:
                                                        ;       f<0~7> = tmp-func
                                                        ;       f<8~15>= &heap-n
    0x100003d68 <+152>: bl     0x100003f54              ; symbol stub for: swift_endAccess
    
    0x100003d6c <+156>: ldr    x2, [sp, #0x28]          ; x2 = *(sp + 0x28) = 32(读操作)
    0x100003d70 <+160>: ldr    x3, [sp, #0x30]          ; x3 = *(sp + 0x30) = 0
    0x100003d74 <+164>: ldr    x0, [sp, #0x40]          ; x0 = *(sp + 0x40) = &f
    0x100003d78 <+168>: sub    x1, x29, #0x40           ; x1 = x29 - 0x40 = &tmp-local-1
    0x100003d7c <+172>: str    x1, [sp, #0x48]          ; *(sp + 0x48) = &tmp-local-1
    0x100003d80 <+176>: bl     0x100003f3c              ; symbol stub for: swift_beginAccess
                                                        ;   准备读取全局对象f

    0x100003d84 <+180>: ldr    x9, [sp, #0x38]          ; x9 = *(sp + 0x38) = &f - 0x10
    0x100003d88 <+184>: ldr    x8, [sp, #0x40]          ; x8 = *(sp + 0x40) = &f
    0x100003d8c <+188>: ldr    x9, [x9, #0x10]          ; x9 = *(x9 + 0x10) = f
    0x100003d90 <+192>: str    x9, [sp, #0x50]          ; *(sp + 0x50) = f
    0x100003d94 <+196>: ldr    x20, [x8, #0x8]          ; x20 = *(x8 + 8) = &heap-n
    0x100003d98 <+200>: stur   x20, [x29, #-0x48]       ; *(x29 - 0x48) = &heap-n
    0x100003d9c <+204>: mov    x0, x20                  ; x0 = &heap-n
    0x100003da0 <+208>: bl     0x100003f6c              ; symbol stub for: swift_retain
                                                        ;   heap-n<7~15> = 0x4_00_00_00_03

    0x100003da4 <+212>: ldr    x0, [sp, #0x48]          ; x0 = *(sp + 0x48) = &heap-n
    0x100003da8 <+216>: bl     0x100003f54              ; symbol stub for: swift_endAccess
        
    0x100003dac <+220>: ldr    x8, [sp, #0x50]          ; x8 = *(sp + 0x50) = f
    0x100003db0 <+224>: mov    w9, #0x14                ; w9 = 20 
    0x100003db4 <+228>: mov    x0, x9                   ; x0 = 20
    0x100003db8 <+232>: blr    x8(0x100003f28 )         ; call(f<0~7>) ==> tmp_func(20), 为了方便直接将该函数贴在下面


; swift`partial apply for closure #1 in test():
->  0x100003f28 <+0>: mov    x1, x20                    ; x1 = &heap-n
    0x100003f2c <+4>: b      0x100003e68                ; 调用 test, 参数:
                                                        ;   x0: 20, x1:&heap-n
                                                        

    0x100003dbc <+236>: ldur   x0, [x29, #-0x48]        ; x0 = *(x29 - 0x48) = &heap-n
    0x100003dc0 <+240>: bl     0x100003f60              ; symbol stub for: swift_release
                                                        ;   heap-n<7~15> = 0x2_00_00_00_03
                                                        ;   即当前有2个引用者, 可以看出就是 lambda和f
    0x100003dc4 <+244>: mov    w0, #0x0                 ; =0 
    0x100003dc8 <+248>: ldp    x29, x30, [sp, #0xa0]
    0x100003dcc <+252>: ldp    x20, x19, [sp, #0x90]
    0x100003dd0 <+256>: add    sp, sp, #0xb0
    0x100003dd4 <+260>: ret    
```

从汇编中可以看出当从函数中返回lambda, 并且lambda内部引用了局部对象后, swift会将局部对象做成堆中的对象, 并且保存在后8字节的空间中. 后续相关的引用将会涉及ARC. 

### 闭包[^ann-closures]
上小节最后的情况其实就是闭包, 形成闭包的必备条件:
1. 存在lambda或嵌套函数
2. 该lambda或嵌套函数内部引用了局部对象(<font color = red>不论该对象是否write</font>)

当具备这2个条件后, 并且:
1. 该lambda或嵌套函数被返回到外界
2. 该lambda或嵌套函数被其他对象(<font color = red>不同作用域</font>)接收
3. 该lambda或嵌套函数被当作函数参数
    - 其实这一条就是第2条, 不同作用域的对象接收时, 有一种情况就是函数参数, 相当于在另一个函数作用域下的对象引用了它

满足三者之一时, 编译器才会真正的将lambda所引用的局部对象做复制到heap的操作, 此刻形成闭包环境(<font color = red>简称闭包</font>). 形成的闭包对象至少16字节:
1. 前8字节是一个中转函数的地址, 该函数由swift编译器实现, 内部直接调用闭包的真正实现地址, 并传递相关的参数
2. 后8字节是闭包实现机制:为了对引用的局部对象而做的内存管理, 直接开辟的堆地址(<font color = red>当前测试中只引用了1个局部对象</font>)

相对的下面这些情况其实并未构成闭包:
1. 返回了lambda或嵌套函数, 但它们内部的实现没有引用任何局部对象
2. lambda或嵌套函数没有任何接收者, 即使它们内部的实现引用了局部对象

```swift
var n = 20
func test() -> (Int) -> Int{
    // 虽然返回了, 但内部没有引用任何局部对象
    return {
        n += $0
        return n
    }
}
// 相当于在全局区返回lambda, 必须接收或忽略lambda
_ = test()



func test2() {
    var n = 20

    // 引用了局部对象, 但是并未返回给外界
    // 事实上编译器会做优化, 直接将lambda的实现体嵌入到test2函数中
    let lambda =  {
        n += $0
        return n
    }
    lambda(20)
}
test2()




func test3() {
    var n = 20
    let lambda =  {
        n += $0
        return n
    }
    // 同作用域下的对象引用lambda
    //  将不会形成闭包
    let f = lambda
}
test3()



do {
    var f: (Int) -> Int = {$0}
    func test4() {
        var n = 20

        // 引用了局部对象, 但是并未返回给外界
        // 事实上编译器会做优化, 直接将lambda的实现体嵌入到test2函数中
        let lambda =  {
            n += $0
            return n
        }
        // 不同作用域下的对象引用lambda
        //  将会形成闭包
        f = lambda
    }
    test4()
}


func test5() -> (() -> ())?{
    var n = 20

    let fun = {
        (lambda:() -> ()) in
    }

    let lambda = {
        n += 30
    }
    lambda()
    fun(lambda)
    return nil
}
test5()
// 虽然没有返回lambda, 但内部lambda被当作参数传递给了fun
// 所以lambda构成了闭包, 其实就是不同作用域的对象接收了
```

如果闭包中引用了多个局部对象, 则对应的内存结构为:
1. lambda`<0~7>`: 中转函数的地址
2. lambda`<8~15>`: `&heap-args`
3. `heap-args<0~7>`: 根据swift中的内存结构, 前8字节一般是类型信息(metadata)
4. `heap-args<8~15>`: 引用计数
5. `heap-args.data`: 第16字节开始将是数据部分


<a id="link-ref-class"></a>

### 闭包中引用堆内存中的对象
前面小节中闭包引用的都是值类型, 如果闭包中引用了heap对象则应该是怎样的呢?

```swift
class T {
    var n = 20
}

func test() -> (Int) -> Int{
    var t = T.init()    // 0x3

    return {
        t.n += $0
        return t.n
    }
}

var lambda = test() // 0x3, t的引用计数
var f = lambda      // 0x2_00_00_00_03

f(20)               // 调用前 0x4_00_00_00_03
                    // 调用后 0x2_00_00_00_03
```

笔者这里直接总结:
1. lambda`<0~7>`: 中转函数的地址
2. lambda`<8~15>`: 局部对象t所指向的`&heap-t`

swift在进行ARC时, 当产生调用时做了一次retain操作, 但调用完毕后, 又做了release, 个人不明白这样做的意义. 现在需要考虑的问题是当lambda中引用了多个局部对象时, 其中存在引用类型的对象时, swift管理内存的过程

```swift
class T {
    var n: Int
    init(n: Int) {
        self.n = n
    }
}

func test() -> (Int) -> Int{
    let t1 = T.init(n: 20)
    let t2 = T.init(n: 20)
    return {
        t1.n += $0
        t2.n += $0
        return t1.n + t2.n + $0
    }
}

var lambda = test()
var f = lambda

f(20)
```

```lua
swift`test():
    0x100003920 <+0>:   sub    sp, sp, #0x50
    0x100003924 <+4>:   stp    x20, x19, [sp, #0x30]
    0x100003928 <+8>:   stp    x29, x30, [sp, #0x40]
    0x10000392c <+12>:  add    x29, sp, #0x40
    0x100003930 <+16>:  stur   xzr, [x29, #-0x18]       ; *(x29 - 0x18) = 0
    0x100003934 <+20>:  str    xzr, [sp, #0x20]         ; *(sp + 0x20) = 0
    0x100003938 <+24>:  mov    x0, #0x0                 ; x0 = 0 
    0x10000393c <+28>:  bl     0x1000039c4              ; type metadata accessor for swift.T at <compiler-generated>
                                                        ; x0 = &T.metadata
    0x100003940 <+32>:  mov    x20, x0                  ; x20 = &T.metadata
    0x100003944 <+36>:  str    x20, [sp]                ; *sp = &T.metadata
    0x100003948 <+40>:  mov    w8, #0x14                ; x8 = 20 
    0x10000394c <+44>:  mov    x0, x8                   ; x0 = 20
    0x100003950 <+48>:  str    x0, [sp, #0x8]           ; *(sp + 8) = 20
    0x100003954 <+52>:  bl     0x100003bb0              ; swift.T.__allocating_init(n: Swift.Int) -> swift.T at main.swift:25
    0x100003958 <+56>:  ldr    x20, [sp]                ; x20 = &T.metadata
    0x10000395c <+60>:  mov    x8, x0                   ; x8 = &heap-t1
    0x100003960 <+64>:  ldr    x0, [sp, #0x8]           ; x0 = *(sp + 8) = 20
    0x100003964 <+68>:  str    x8, [sp, #0x10]          ; *(sp + 0x10) = &heap-t1
    0x100003968 <+72>:  stur   x8, [x29, #-0x18]        ; *(x29 - 0x18) = &heap-t1
    0x10000396c <+76>:  bl     0x100003bb0              ; swift.T.__allocating_init(n: Swift.Int) -> swift.T at main.swift:25
    0x100003970 <+80>:  str    x0, [sp, #0x18]          ; *(sp + 0x18) = &heap-t2
    0x100003974 <+84>:  str    x0, [sp, #0x20]          ; *(sp + 0x20) = &heap-t2
->  0x100003978 <+88>:  adrp   x8, 1                
    0x10000397c <+92>:  add    x8, x8, #0x40            
    0x100003980 <+96>:  add    x0, x8, #0x10            
    0x100003984 <+100>: mov    w8, #0x20                ; =32 
    0x100003988 <+104>: mov    x1, x8
    0x10000398c <+108>: mov    w8, #0x7                 ; =7 
    0x100003990 <+112>: mov    x2, x8
    0x100003994 <+116>: bl     0x100003e54              ; symbol stub for: swift_allocObject
                                                        ;   x0: 类型信息  
                                                        ;   x1: 32(大小)
                                                        ;   x2: 7
                                                        ;   从这里可以看出: 要开辟一个新的arg-heap来存储heap-t1, heap-t2
                                                        ;       arg-heap<16~23> = &heap-t1
                                                        ;       arg-heap<24~31> = &heap-t2

    0x100003998 <+120>: ldr    x8, [sp, #0x10]          ; x8 = *(sp + 0x10) = &heap-t1
    0x10000399c <+124>: mov    x1, x0                   ; x1 = &arg-heap
    0x1000039a0 <+128>: ldr    x0, [sp, #0x18]          ; x0 = *(sp + 0x18) = &heap-t2
    0x1000039a4 <+132>: str    x8, [x1, #0x10]          ; *(x1 + 0x10) = &heap-t1
    0x1000039a8 <+136>: str    x0, [x1, #0x18]          ; *(x1 + 0x18) = &heap-t2
    0x1000039ac <+140>: adrp   x0, 0                    ;
    0x1000039b0 <+144>: add    x0, x0, #0xe3c           ; partial apply forwarder for closure #1 (Swift.Int) -> Swift.Int in swift.test() -> (Swift.Int) -> Swift.Int at <compiler-generated>
    0x1000039b4 <+148>: ldp    x29, x30, [sp, #0x40]    ; x0 = tmp-func
    0x1000039b8 <+152>: ldp    x20, x19, [sp, #0x30]
    0x1000039bc <+156>: add    sp, sp, #0x50
    0x1000039c0 <+160>: ret    


; 截止 &heap-t1, &heap-t2, &arg-heap的引用计数都是0x3

swift`main:
    0x100003818 <+0>:   sub    sp, sp, #0xb0
    0x10000381c <+4>:   stp    x20, x19, [sp, #0x90]
    0x100003820 <+8>:   stp    x29, x30, [sp, #0xa0]
    0x100003824 <+12>:  add    x29, sp, #0xa0
    0x100003828 <+16>:  bl     0x100003920              ; swift.test() -> (Swift.Int) -> Swift.Int at main.swift:30
->  0x10000382c <+20>:  mov    x8, x0                   ; x8 = tmp-func
    0x100003830 <+24>:  adrp   x9, 5                    
    0x100003834 <+28>:  str    x9, [sp]                 ; *sp = x9 = &lambda - 0x170
    0x100003838 <+32>:  adrp   x0, 5
    0x10000383c <+36>:  add    x0, x0, #0x170           ; swift.lambda : (Swift.Int) -> Swift.Int
    0x100003840 <+40>:  str    x0, [sp, #0x8]           ; *(sp + 0x8) = &lambda
    0x100003844 <+44>:  str    x8, [x9, #0x170]         ; *(x9 + 0x170) = x8 ==> lambda<0~7> = tmp-func
    0x100003848 <+48>:  str    x1, [x0, #0x8]           ; *(x0 + 8) = x1 ==> lambda<7~15> = &arg-heap
    0x10000384c <+52>:  sub    x1, x29, #0x28           ; x1 = x29 - 0x28 = &tmp-local-0
    0x100003850 <+56>:  str    x1, [sp, #0x10]          ; *(sp + 0x10) = &tmp-local-0
    0x100003854 <+60>:  mov    w8, #0x20                ; x8 = 32 
    0x100003858 <+64>:  mov    x2, x8                   ; x2 = 32(read)
    0x10000385c <+68>:  str    x2, [sp, #0x28]          ; *(sp + 0x28) = 32
    0x100003860 <+72>:  mov    x3, #0x0                 ; x3 = 0 
    0x100003864 <+76>:  str    x3, [sp, #0x30]          ; *(sp + 0x30) = 0
    0x100003868 <+80>:  bl     0x100003e60              ; symbol stub for: swift_beginAccess
                                                        ;   准备访问全局对象 lambda

    0x10000386c <+84>:  ldr    x9, [sp]                 ; x9 = *sp = &lambda - 0x170
    0x100003870 <+88>:  ldr    x8, [sp, #0x8]           ; x8 = *(sp + 0x8) = &lambda
    0x100003874 <+92>:  ldr    x9, [x9, #0x170]         ; x9 = lambda<0~7> = tmu-func
    0x100003878 <+96>:  str    x9, [sp, #0x18]          ; *(sp + 0x18) = tmp-func
    0x10000387c <+100>: ldr    x0, [x8, #0x8]           ; x0 = *(x8 + 8) ==> lambda<7~15> = &arg-heap
    0x100003880 <+104>: str    x0, [sp, #0x20]          ; *(sp + 0x20) = &arg-heap
    0x100003884 <+108>: bl     0x100003e9c              ; symbol stub for: swift_retain
                                                        ;   对arg-heap做引用计数, 因为全局对象f要引用lambda
                                                        ;   所以应该对lambda的数据部分做retain操作.
                                                        ;   其实这就是典型的ARC, 全局对象f在逻辑上相当于只引用了
                                                        ;   lambda, 所以它只管对lambda本身的数据做retain, 不用关心
                                                        ;   lambda内部的数据内存管理
                                                        ;   0x2_00_00_00_03

    0x100003888 <+112>: ldr    x0, [sp, #0x10]          ; x0 = *(sp + 0x10) = &tmp-local-0
    0x10000388c <+116>: ldr    x10, [sp, #0x18]         ; x10= *(sp + 0x18) = tmp-func
    0x100003890 <+120>: ldr    x8, [sp, #0x20]          ; x8 = *(sp + 0x20) = &arg-heap
    0x100003894 <+124>: adrp   x11, 5                   ; x11 = &lambda - 0x170
    0x100003898 <+128>: str    x11, [sp, #0x38]         ; *(sp + 0x38) = &lambda - 0x170
    0x10000389c <+132>: adrp   x9, 5                    ; x9 = &lambda - 0x170
    0x1000038a0 <+136>: add    x9, x9, #0x180           ; swift.f : (Swift.Int) -> Swift.Int
    0x1000038a4 <+140>: str    x9, [sp, #0x40]          ; *(sp + 0x40) = &f
    0x1000038a8 <+144>: str    x10, [x11, #0x180]       ; *(x11 + 0x180) = x10 ==> *(&lambda + 0x10) = tmp-func ==> f<0~7> = tmp-func
                                                        ;   lambda的f的地址是相邻的, 都是16字节
    0x1000038ac <+148>: str    x8, [x9, #0x8]           ; *(x9 + 0x8) = x8 ==> f<8~15> = &arg-heap
    0x1000038b0 <+152>: bl     0x100003e84              ; symbol stub for: swift_endAccess

    0x1000038b4 <+156>: ldr    x2, [sp, #0x28]          ; x2 = *(sp + 0x28) = 32(read)
    0x1000038b8 <+160>: ldr    x3, [sp, #0x30]          ; x3 = *(sp + 0x30) = 0
    0x1000038bc <+164>: ldr    x0, [sp, #0x40]          ; x0 = *(sp + 0x40) = &f
    0x1000038c0 <+168>: sub    x1, x29, #0x40           ; x1 = x29 - 0x40 = &tmp-local-1
    0x1000038c4 <+172>: str    x1, [sp, #0x48]          ; *(sp + 0x48) = &tmp-local-1
    0x1000038c8 <+176>: bl     0x100003e60              ; symbol stub for: swift_beginAccess
                                                        ;   准备访问全局对象f

    0x1000038cc <+180>: ldr    x9, [sp, #0x38]          ; x9 = *(sp + 0x38) = &lambda - 0x170
    0x1000038d0 <+184>: ldr    x8, [sp, #0x40]          ; x8 = *(sp + 0x40) = &f
    0x1000038d4 <+188>: ldr    x9, [x9, #0x180]         ; x9 = *(&lambda - 0x170 + 0x180) = f<0~7> = tmp-func
    0x1000038d8 <+192>: str    x9, [sp, #0x50]          ; *(sp + 0x50) = tmp-func
    0x1000038dc <+196>: ldr    x20, [x8, #0x8]          ; x20 = *(x8 + 0x8) = f<8~15> = &arg-heap
    0x1000038e0 <+200>: stur   x20, [x29, #-0x48]       ; *(x29 - 0x48) = &arg-heap
    0x1000038e4 <+204>: mov    x0, x20                  ; x0 = &arg-heap
    0x1000038e8 <+208>: bl     0x100003e9c              ; symbol stub for: swift_retain
                                                        ;   arg-heap.ref-count = 0x4_00_00_00_03
    0x1000038ec <+212>: ldr    x0, [sp, #0x48]          ; x0 = *(sp + 0x48) = &tmp-local-1
    0x1000038f0 <+216>: bl     0x100003e84              ; symbol stub for: swift_endAccess

    0x1000038f4 <+220>: ldr    x8, [sp, #0x50]          ; x8 = *(sp + 0x50) = tmp-func
    0x1000038f8 <+224>: mov    w9, #0x14                ; x9 = 20 
    0x1000038fc <+228>: mov    x0, x9                   ; x0 = 20
    0x100003900 <+232>: blr    x8                       ; tmp-func(20)
    0x100003904 <+236>: ldur   x0, [x29, #-0x48]        ; x0 = *(x29 - 0x48) = &arg-heap
    0x100003908 <+240>: bl     0x100003e90              ; symbol stub for: swift_release
                                                        ; 调用完毕后 0x2_00_00_00_03
    0x10000390c <+244>: mov    w0, #0x0                 ; =0 
    0x100003910 <+248>: ldp    x29, x30, [sp, #0xa0]
    0x100003914 <+252>: ldp    x20, x19, [sp, #0x90]
    0x100003918 <+256>: add    sp, sp, #0xb0
    0x10000391c <+260>: ret    
```

从汇编可以看出来, 当嵌套函数引用了多个class类型的对象时, 实际上它将这些对象整合到了一个新的heap中, 并集中对这个heap做ARC管理. 其实闭包形成的函数类型逻辑上相当于这样一个类型:

```swift
class T {
    var n: Int
    init(n: Int) {
        self.n = n
    }
}

func test() -> (Int) -> Int{
    let t1 = T.init(n: 20)
    let t2 = T.init(n: 20)
    return {
        t1.n += $0
        t2.n += $0
        return t1.n + t2.n + $0
    }
}

// 类似于如下这种结构
class lambda_obj {
    var t1, t2: T   
    init(_ arg_1: T, _ arg_2: T){
        self.t1 = arg_1
        self.t2 = arg_2
    }
    func call(_ arg: Int) -> Int {
        t1.n += arg
        t2.n += arg
        return t1.n + t2.n + arg
    }
}
```

### lambda引用函数参数
前面提到过lambda引用局部对象不会管这个对象是否是可写的:

```swift
func test() -> (Int) -> Int{
    let n = 20
    return {
        return n + $0
    }
}
```

如上面这种程序, 也会形成闭包. 按这种逻辑闭包中所引用的局部对象也可以是函数的参数, 而函数的参数有2种: let 和 inout. 

```swift
func test(val: Int, addr: inout Int) -> (Int) -> Int{
    return {
        return val + addr + $0 // error, lambda不能引用inout类型的对象
    }
}

var num = 30
var lambda = test(val: 20, addr: &num)
```

swift中不允许lambda中引用inout类型的参数. 在13章节笔者提到过inout和指针本质上是一样的东西, 只是在编码层面的格式不同, 在这里无法在lambda中引用inout参数, 但可以引用局部对象的地址或直接引用类型为指针的参数:

```swift
func test(val: Int, addr: inout Int, pointer: UnsafePointer<Int>) -> (Int) -> Int{
    var tmp = 20
    return {
        // 直接引用指针参数
        let tmp_pointer = pointer
        // 使用指针引用局部对象, 没有问题, 实际上指向了heap
        let ptr = UnsafePointer<Int>.init(&tmp)
        return ptr.pointee  + $0
    }
}
```

<a id="link-lamdba-ref-inout"></a>

### 能引用到inout参数
引用inout参数有2个条件: 
1. 必须匿名, 可以立即调用
    - 也可以是let, 但不能产生调用
2. 不能超出lambda所在的函数

```swift
func test(_ a: inout Int, _ f: () -> ()) -> Any{
    // let引用lambda, 不产生调用时, 没有问题
    let n = {       // __code_0
        a += 20
    }
    
    //n(), 产生调用直接报错
    
    // 没有参数接收, 然后可以直接调用(也可不调用)
    _ = { a += 20 }() 

    // 并且n不会出test的作用域
    return 20       // __code_1
} 
```

如果`__code_0`改成var或`__code_1`改成`return n`则就报错, 出于这样的特殊情况, 以struct来举例说明:

```swift
struct M{
    init(_ num: inout Int) {
        // let定义lambda, 可以引用到inout参数
        let n = {
            num += 20
            self.test(&num)
        }
    }

    
    func test(_ num: inout Int){
        // 当前lambda也是未出test作用域, 所以可以引用到inout参数
         _ = {
            num += 20
        }
    }
}
```



### lambda为什么危险
从编码的角度来看, lambda之所以危险是因为构成了闭包环境, 所以可能涉及到前面屡次提到的局部对象的内存管理. 即lambda脱离了它的作用域, 还是举例:
1. lambda引用了外围的局部对象
2. lambda形成闭包(<font color = red>被不同作用域对象接收</font>)
3. lambda在调用点脱离了原来的作用域

但swift已经在编译层面解决了这种内存管理问题, 所以应该放心大胆的使用lambda, 而不在乎它是否形成了闭包. 其实本质就是: 
1. 没有形成闭包的lambda是安全的, 因为它没有访问任何局部对象, 所以不会牵扯到复杂的内存管理.
2. 形成了闭包的lambda脱离了作用域后就显得不安全, 但<font color = red>本质上是安全的</font>.

> 闭包中还存在其他方面的内存管理细节, 这里先不管

swift中将脱离了作用域的闭包或闭包表达式统称为逃逸闭包, 它是不安全的 


### 逃逸闭包
上一小节最后引出了逃逸闭包的基本概念, 总结起来其实本质就是lambda(<font color = red>可能未形成闭包</font>)的调用脱离了它所在的作用域. 

```swift
do {
    func sync_call(_ lambda: (Int) -> Int){
        print(lambda(20))
    }
    func test(){
        let n = 100
        let lambda = {
            // 引用局部对象
            $0 + n  // __code_lambda
        }

        // 被不同作用域的对象接收,
        // lambda将构成闭包
        sync_call(lambda)
    }
    test()
} 

// 像这种情况单纯代码的实现, 其实编译器完全可以进行这样的优化:
do {
    func sync_call(_ lambda: (Int) -> Int){
        print(lambda(20))
    }
    func test(){
        let lambda = {
            // 直接改成字面量, 这样不用多开辟heap空间
            $0 + 100  
        }

        // 不会产生闭包, 因为后8字节为空
        sync_call(lambda)
    }
    test()
}
```

从代码层面上看当调用`sync_call`时其实是安全的:
1. 对于第1种编译器的实现: 假设swift中并未做局部对象n的复制操作, 在`sync_call`函数中也可以通过n的地址访问到n, 因为n这个时候还在栈桢中. 
2. 对于第2种编译器的优化: 因为lambda中没有访问任何局部对象, 所以一定是安全的

它们安全是因为本质上lambda的调用并未离开作用域(需要强调一点lambda的调用点未离开作用域和lambda被不同作用域的对象接收不构成矛盾). 但作为编译器,它是不确定lambda的调用是不是脱离了作用域!! 因为它不可能知道`sync_call`函数内部是怎么调用`lambda`的, 可能是异步后调用, 这样就脱离了lambda原本的作用域.  下面的测试:

```swift
// 全局对象
var ptr:(() -> Int)? = {0}

// 一个临时的闭包表达式
//  定义后直接调用, 因为位于全局区
//  所以这里必须忽略它
// 它主要的作用是创建lambda并被ptr引用导致lambda形成闭包
_ = {
    var n = 20
    let lambda = {
        n += 30 // 引用局部对象
        return n
    }
    // 因为这句赋值代码, 所以lambda构成了闭包
    ptr = lambda
}()

let tmp_lambda = {
    (lambda: () -> Int) in

    // 准备多线程环境下调用
    var pid = os._opaque_pthread_t()
    var pointer:pthread_t? = withUnsafeMutablePointer(to: &pid, {$0})
    

    let call =  withUnsafeMutablePointer(to: &ptr, {UnsafeMutableRawPointer($0)})
    pthread_create(withUnsafeMutablePointer(to: &pointer, {$0}), nil, {
        sleep(1)

        // 这里发生了编译期error
        //  pthread_create函数的第3个参数声明的类型
        //  是一个闭包表达式:
        //      (UnsafeMutableRawPointer) -> UnsafeMutableRawPointer?
        //  会被编译器桥接成系统函数(C语言)下的函数指针:
        //      void* (*) (void*)
        //  这种机制是通过 @convention(c) 来标注闭包表达式的类型:
        //      @convention(c) (UnsafeMutableRawPointer) -> UnsafeMutableRawPointer?
        //  而在闭包表达式的执行体内是不允许访lambda这种局部的闭包,
        //  所以笔者将全局对象ptr转换成了pthread_create的参数, 
        //  然后再在执行体中拿到
        //print(lambda()) // __code_call_1

        // 拿到当前执行体中的参数, 然后转换成 ()->Int类型再调用
        print(($0).load(as: type(of: ptr))!())

        return nil
    }, call)
}

tmp_lambda(ptr!) 

// 主线程挂起
os.pause()
```

上述程序中最终对lambda的调用点脱离了其作用域, 但其实没有任何问题, 因为存在闭包的安全机制. 

一个函数的参数为函数类型时, 编译器或程序员并不清楚它是否会脱离作用域被调用, 为了明确表达出这种意向, swift提供了`@escaping`来修饰这种参数, 目的就是告诉编译器或调用者该闭包会脱离作用域调用(<font color = red>实际权掌握在接收函数中, 它也可以不延迟调用</font>). swift将这种被`@escaping`修饰的函数类型称为逃逸闭包

逃逸闭包只是一种安全警告. 同时它还存在其他特性:
1. 禁止在逃逸闭包内部调用非逃逸闭包, 这个是从逻辑上来强调调用的安全性, 因为逃逸闭包和非逃逸闭包不在同一作用域, 存在风险, 编译器禁止这种行为 
2. 禁止在逃逸闭包中引用inout参数(<font color = red>绝大部分的lambda都是这样</font>)
    - 有一种[特殊情况](#link-lamdba-ref-inout)
3. 禁止在逃逸闭包中引用可变的self
    - 即在sturct的mutating方法中
4. 必须在逃逸闭包指定引用类型的调用者self(<font color = red>语法规定</font>)

> 逃逸闭包的闭包表达式并不一定是闭包环境

```swift
import os
import Dispatch
do {
    // 返回值构成闭包环境
    let get_lambda = {
        var n = 20
        return {
            n += 30
            return n
        }
    }

    
    let tmp_lambda = {
        // 参数是一个逃逸闭包
        (lambda: @escaping() -> Int) in

        // 调用权在调用者手里, 可以立即在当前自己的作用域调用
        lambda()
        
        // Dispatch的async的闭包也是逃逸闭包,
        //  而且是明显的逃逸闭包, 因为是异步调用
        Dispatch.DispatchQueue.global().async {
            print(lambda())
        }
    }
    tmp_lambda(get_lambda())
}

os.pause()
```

这里`@escaping`只是修饰一个闭包表达式可能被延迟调用, 但这个闭包表达式并不一定是闭包环境, 如:

```swift
import os
import Dispatch

do {
    // 这里没有引用局部对象, 所以不会构成闭包
    let get_lambda = {
        return {
            return 30
        }
    }

    let tmp_lambda = {
        (lambda: @escaping() -> Int) in
        Dispatch.DispatchQueue.global().async {
            print(lambda())
        }
    }

    tmp_lambda(get_lambda())
}
os.pause()
```

程序中`get_lambda`返回了闭包表达式, 但闭包表达式的实现中并未引用任何局部对象, 所以不构成闭包, 但`tmp_lambda`的参数被修饰为`@escaping`表示闭包表达式可能被延迟调用, 但这个参数对于`tmp_lambda`自身来说并不知道所接收的参数关联的lambda是不是闭包, 但不影响`@escaping`的修饰


### 无法直接定义非逃逸闭包
笔者这里直接总结了:
1. 所有定义的闭包默认都是escaping(<font color = red>有接收者</font>)
    - 包括使用对象接收函数名
    - 包括返回一个闭包
2. escaping可以转换成no escaping, 这个转换必须通过函数或其他方式
3. no escaping不能转换成escaping

总结no escaping只存在于函数参数, 其他地方都是escaping. <font color = red>有一种情况是没有接收者的lambda, 此刻在代码层面它是no escaping, 但事实会被编译器优化直接展开代码在定义的位置</font>


```swift
// fn = escaping
//  默认定义的闭包是escaping
var fn: ((Any)->()) = {print($0)}

// 函数明确接收一个 escaping,
//  所以不能传递no escaping
func test(_  fun: @escaping (Any) -> ()){}

// 函数返回的也是 escaping
func get() -> (Any) -> () {
    {print($0)}
}


// 函数接收一个 no escaping
func Init(tmp_fn:  (Any) -> () = {print($0)}) {

    // t: no escaping
    let t = tmp_fn

    // n: no escaping
    //  可以互相赋值
    var n = t

    // escaping 转换为 no escaping
    n = fn

    fn = n      // error, 尝试将 no escaping(n) 转换为 escaping(fn)

    fn = get()  // 正确

    test(n)     // error, 尝试将 no escaping(n) 转换为 escaping

    Init(tmp_fn: n) // 正确, 类型一样都是 no escaping

    test(get()) // 正确

    var f = {print($0)} // 局部对象也是escaping

    f = fn      // 正确
}

// 从escaping(fn) 转换为 no escaping(tmp_fn)
Init(tmp_fn: fn) 
```

### 成员是闭包时的细节
因为闭包在定义时都是escaping, 当一个对象声明了闭包时, 当它的赋值是操作是函数参数时, 该参数必须是escaping

```swift
// 对象声明了可选闭包(escaping)
var fn: ((Any) -> Void)?

func Init(tmp_fn:  (Any) -> ()) {
    // 错误, 因为no escaping不能转换为escaping
    fn = tmp_fn
}

func Init2(tmp_fn: @escaping (Any) -> ()){
    // 没有问题
    fn = tmp_fn
}

Init(){print($0)} 
Init2(){print($0)} 
```

由于存在这种情况, 所以当swift中的类型中有成员声明的是函数类型时, 它们默认就是escaping的, 所以在初始化时构造它们是要注意加上escaping

```swift
struct T {
    // escaping
    var fn: () -> () = {}

    // 构造时, 必须指定参数为 escaping
    init(fn: @escaping () -> Void) {
        self.fn = fn
    }

    // mutating表示修改self
    //  同时参数必须为 escaping
    mutating func mod(_ fn: @escaping()->()){
        self.fn = fn
    }
}
```

对于struct来说, 不能在mutating的成员方法中使用escaping的lambda中引用self.

```swift
struct T {
    var fn: () -> () = {}
    init(fn: @escaping () -> Void) {
        self.fn = fn
    }

    mutating func mod(_ fn: @escaping()->()){
        self.fn = fn
    }


    mutating func test(_ a: inout Int){
        // escaping, 
        //  但它是一个忽略的lambda,属于特殊的,
        //  可以引用inout参数, 也可以引用 mutating self(其实本质也是地址)
        {
            a += 20
            fn()
        }()

        // escaping closures
        //  不能引用inout
        //  不能引用 mutating self(地址)
        var tmp = {
            a += 20
            // 禁止在 mutating方法中访问self
            fn()
        }


        // 同上
        mod {
            a += 20
            fn()
        }

        // 同上
        DispatchQueue.global().async{
            a += 20
            fn()
        }
    }
} 
```

在class中更为特殊, 必须指定调用者self: 

```swift


class T {
    var fn: () -> ()
    init(fn: @escaping () -> Void) {
        self.fn = fn
    }

    func mod(_ fn: @escaping ()->()){
        self.fn = fn
    }

    func test(_ a: inout Int, _ f: inout () -> ()){
        // fn在调用时必须指定调用者

        let n = {
            a += 20
            self.fn()
        }

        mod {
            self.fn()
        }

        DispatchQueue.global().async{
            self.fn()
        }
    }
}
```


### 循环引用
[前面](#link-ref-class)已经探究过闭包中引用一个堆内存时, 编译器将会做好ARC的工作, 所以这里就可能存在循环引用的内存问题

```swift
class T{
    let n: Int
    var cbk: ()->() = {}
    init(n: Int) {
        self.n = n
        print("init<\(n)>")
    }
    deinit{
        print("deinit<\(n)>")
    }
}



do {
    let t = T(n: 20)    // <t, 0x3>, <t.cbk, value0, 0x3>

    // 编译器会在这里做好ARC:
    //  <t.cbk, value0, 0>      
    //  <t.cbk, value1, 0x3>    t对cbk强引用
    //  <t, 0x2_00_00_00_03>    t.cbk对t进行强引用
    t.cbk = {          
        print(t.n)      
    }
}   // <t, 0x3>
    // <t.cbk, value1, 0x3>
```

解决方案和OC中一样, 其中一方放弃持有, 可以使用weak或unowned, 修改如下

```swift
do {
    let t = T(n: 20)
    t.cbk = {
        // 不安全, 它修饰的对象就是原始类型
        [unowned t] in
        print(t.n)
    }
} 
```

关于class之间的内存管理会在class章节详细探究, 这里先简单看闭包中的循环引用. ARC管理的是堆内存, 所以weak和unowned只能作用于heap的对象上, 具体就是引用类型, 所以从这一点也可以解释函数类型的对象其实就是swift中的引用类型的一种. 

weak和unowned的区别:
1. 它们都被ARC管理, 但不会对所引用的对象做retain, release操作
2. weak使用的过程是安全的, ARC发现所引用的对象被释放后, 同时安全的将该对象所有关联的weak指针全部置空, 所以weak修饰的对象默认是可选类型, 在使用weak对象时, 必须先解包判断
3. unowned的效率要比weak高, 因为当它所引用的对象被置空后, 它本身不会发生变化, 所以owned修饰的就是对象的原始类型, 同时由于unowned还存储着对象的地址, 这个时刻的地址已经是非法的了, 所以它是不安全的, 它具体的应用环境要看业务场景了

闭包中使用weak和unowned的格式:

```swift
do {
    let t = T(n: 20)
    t.cbk = {
#if false
    定义了3个弱指针:
        unowned local_t = t
            不安全的弱指针
            为引用的t对象起一个名字
            local_t的类型就是 T

        weak safe_local_t
            安全的弱指针
            为引用的t对象起一个名字
            safe_local_t 的类型是 T?

        weak t
            安全的弱指针
            直接使用局部对象t覆盖掉外层对象t的名字
#endif
        [unowned local_t = t, weak safe_local_t = t, weak t] in
        print(t?.n)
    }
} 
```


### 自动闭包
所谓自动闭包就是自动创建闭包, 这个其实属于类型转换的一部分:
1. 函数的参数是函数类型
2. 函数类型是固定的闭包表达式类型, `() -> T`
3. 在调用函数时直接传递T对象, 编译器会自动将传递的T对象转换成`{() -> T in t}`

```swift
// 声明了一个自动闭包
//  调用者必须传递String类型的对象(eg: str)
//  编译器将转换成 {str}
func test(_ lam:@autoclosure () -> String){
    let str = lam()
    print(str)
}
test("hello")
    // 相当于   test({
                    () -> String
                    return "hello"
                })
```

举一个自动闭包的案例:

```swift
// 自定义运算符, swift中可以自定义的运算符有很多, 包括Unicode中的数学字符等
prefix operator «
prefix operator »

extension StringLiteralType {

    // case模式匹配: 
    // __code_case_parten
    static func ~= (p: @autoclosure () -> (Self) -> Bool, cmp: Self) -> Bool {
        cmp.isEmpty ? false : p()(cmp)
    }

    // __code_prefix
    static prefix func « (_ this: Self) -> (Self) -> Bool {{
        $0.hasPrefix(this)
    }}

    // __code_suffix
    static prefix func » (_ this: Self) -> (Self) -> Bool {{
        $0.hasSuffix(this)
    }}
}

let lam = {
    (arg: String) in
    switch arg {
        case «"he":
            print("^he")

        case »"ry":
            print("jy$")

        default:
            print("default")
    }
}

lam("hello")
lam("tierry")
```

代码的功能是使用case判断字串是不是以`he`开头或`ry`结尾. 里面主要牵扯到编译器的默认行为:
1. 编译器在编译器case时, 如果不能识别case与switch的比较, 则会进入到模式匹配
2. 编译器会尝试查找`«`的函数重载
3. 调用`«`获取到了一个闭包表达式
4. 然后将闭包表达式传递给了`~=`函数的第1个参数, 该参数是一个自动闭包, 会将传递过来的闭包加以包装:
5. 将switch的对象传递给`~=`的第2个参数
6. 函数内部做处理, 返回比较的结果

```swift
// 实际 ~= 的第1个参数被编译器转换成了类似下面的函数:
func auto_lambda() -> (String) -> Bool{
    return {
        (switch_str: String) -> Bool in 
        return switch_str.hasPrefix(case_str)
    }
}
// 其中case_str是最初由 case调用 « 形成闭包时所引用的 "he"

// 在 ~= 内部, 先判断了 switch_str是不是空, 若是空, 直接返回false, p()的调用不会产生, 提高了效率
//  否则p()相当于  auto_lambda(), 获取到内部的lambda, 然后再传递 ~= 的第2个参数, 最后判断
```



[^ann-closures]: 在这里笔者将闭包和闭包表达式做了概念上的区分. 闭包表达式(lambda)是形成闭包的必要条件, 闭包是lambda的充分条件. 只有当lambda的后8字节是一个heap地址时, 在逻辑上就可以形成闭包环境的必备条件



</font>
