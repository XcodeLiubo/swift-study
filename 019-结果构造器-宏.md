<font size = 4>

### 突破语法限制
笔者从事iOS的经历中最痛苦的莫过于排版界面时重复一样的UI代码, 如下面这种布局:

<img src="./.image/009.png"/>

```objc
- (void)viewDidLoad {
    [super viewDidLoad];

    UIImageView* iv = [UIImageView new];
    iv.contentMode = 2;
    iv.backgroundColor = UIColor.lightGrayColor;
    __weak UIImageView* wiv = iv;
    [iv sd_setImageWithURL:[NSURL URLWithString:@"http://gips0.baidu.com/it/u=3602773692,1512483864&fm=3028&app=3028&f=JPEG&fmt=auto?w=960&h=1280"] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) {
        double iv_w = 180;
        double iv_h = 180 * image.size.height / image.size.width;
        double left = 15;
        double space = 12;
        double content_w = wiv.superview.frame.size.width - left * 2;

        UILabel* name_lab = [wiv.superview viewWithTag:999];
        UILabel* info_lab = [wiv.superview viewWithTag:1000];

        double iv_x = left;

        double tle_x = iv_x + iv_w + space;
        double tle_w = name_lab.frame.size.width;
        double tle_h = name_lab.frame.size.height;

        double info_x = tle_x;
        double info_w = content_w - info_x;
        CGSize real_size = [info_lab sizeThatFits:CGSizeMake(info_w, CGFLOAT_MAX)];
        double right_h = tle_h + space + real_size.height;

        double iv_y = (iv.superview.frame.size.height - (iv_h > right_h ? iv_h : right_h)) * .5;
        double tle_y = iv_y;
        double info_y = tle_y + space + tle_h;

        wiv.frame = CGRectMake(iv_x, iv_y, iv_w, iv_h);
        name_lab.frame = CGRectMake(tle_x, tle_y, tle_w, tle_h);
        info_lab.frame = CGRectMake(info_x, info_y, info_w, real_size.height);
    }];
    [self.view addSubview:iv];

    UILabel* name_lab = [UILabel new];
    name_lab.text = @"tierry";
    name_lab.textColor = UIColor.blackColor;
    name_lab.font = [UIFont systemFontOfSize:18 weight:(UIFontWeightBold)];
    name_lab.textAlignment = 1;
    name_lab.tag = 999;
    [name_lab sizeToFit];
    [self.view addSubview:name_lab];

    UILabel* info_lab = [UILabel new];
    info_lab.text = @"hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world";
    info_lab.textColor = UIColor.grayColor;
    info_lab.font = [UIFont systemFontOfSize:12 weight:(UIFontWeightRegular)];
    info_lab.numberOfLines = 0;
    info_lab.tag = 1000;
    [self.view addSubview:info_lab];
} 
```

这种代码在早期的iOS中很常见, 它带来的最主要的问题: 视图的位置需要手动去计算, 这很繁琐. 针对这种情况苹果推导出了AutoLayout, 它主要帮助程序员省去坐标的计算

```objc
- (void)viewDidLoad {
    [super viewDidLoad];

    UIStackView* container_v = [UIStackView new];
    [self.view addSubview:container_v];

    UIImageView* iv = [UIImageView new];
    iv.contentMode = UIViewContentModeScaleAspectFit;
    iv.backgroundColor = UIColor.lightGrayColor;
    [iv sd_setImageWithURL:[NSURL URLWithString:@"http://gips0.baidu.com/it/u=3602773692,1512483864&fm=3028&app=3028&f=JPEG&fmt=auto?w=960&h=1280"]];
    [container_v addSubview:iv];

    UILabel* name_lab = [UILabel new];
    name_lab.text = @"tierry";
    name_lab.textColor = UIColor.blackColor;
    name_lab.font = [UIFont systemFontOfSize:18 weight:(UIFontWeightBold)];
    name_lab.textAlignment = 1;
    name_lab.tag = 999;
    [name_lab sizeToFit];
    [container_v addSubview:name_lab];

    UILabel* info_lab = [UILabel new];
    info_lab.text = @"hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world";
    info_lab.textColor = UIColor.grayColor;
    info_lab.font = [UIFont systemFontOfSize:12 weight:(UIFontWeightRegular)];
    info_lab.numberOfLines = 0;
    info_lab.tag = 1000;
    [container_v addSubview:info_lab];

    [container_v mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.offset(15);
        make.right.offset(-15);
        make.centerY.offset(0);
    }];
    [iv mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.top.bottom.offset(0);
        make.width.equalTo(@180);
        make.height.equalTo(@(180 * 1280.0 / 960));
    }];
    [name_lab mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.equalTo(iv.mas_right).offset(12);
        make.top.equalTo(iv);
    }];
    [info_lab mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.equalTo(name_lab);
        make.top.equalTo(name_lab.mas_bottom).offset(12);
        make.right.offset(0);
    }];
}
```
AutoLayout推出后出现了比较多的布局框架, 笔者用的是比较流行的, 它简化了苹果的API使用, 但从编码上并未减少太多. 笔者是一个懒散的人, 其实不想花太多功夫去写一个自己用的好的布局框架, 平时只是将自己用的框架做一下扩展(<font color = red>后面给出截图</font>), 没想到自己多年前利用macro实现的布局思想已经在当今移动端泛乱了, 并且如今的SwiftUI也是这种思想, 只不过SwiftUI有了语言的支持, 和swfitUI比起来, 我那是小巫见大巫了, 但其实对于笔者来说思想最重要, 因为当时有这种想法, 所以我才实现了, 并且笔者自认为自己的那一套确实是很创新的, 它完全是在编译时期, 项目要是不用它就不会参与编译, 也没有任何和原生API的冲突. 笔者提这些是为后续从这种思想来引导出builder, 以及builder下SwiftUI的机制. 

笔者并不打算介绍曾经实现框架的流程, 只给出一些代码片段, 直观感受一下前后的编码方式:


<img src="./.image/010.png"/>
<img src="./.image/011.png"/>
<img src="./.image/012.png"/>

> 这个不是OC中的block, 这些只是用法的一部分, 实现是基于macro, 依赖MyLayout, 也有一部分是系统原生的AutoLayout. 该实现从编码方式上和以前完全不同, 这种相当于是使用宏自定义了自己的流程语言. 后续就是要在swift中往这个方向迈进 

### builder的概念[^ann-result-builder]
`swift5.4`中引入了结果构造器, 它旨在swift中定义DSL[^ann-dsl]语言. 这里简单提一下: 定义一个语言并不是说写一个语言解释器, 然后将这个语言解释器交给swift编译器去调用. 事实是swift编译器将语言中最核心的 <font color = red>顺序, 条件, 循环</font>抽象了出来, 这种抽象的实现机制就是回调函数. 具体来说swift识别用户书写的代码, 如果这些代码是顺序执行的部分, 则将这些执行的结果整合在一起通过函数回调给用户.  条件和循环也是这样一个过程, 只不过回调的函数不一样. 在这个过程中:
1. swift是桥梁
2. 自定义的DSL其实本质还是swift表达式语句, 并不是真正的在定义一个新的语言. 但从逻辑上来看确实是在自定义顺序,条件, 循环
3. 用户要开启DSL功能, 目的是告诉swift, 下面要书写的代码是自定义的, 请帮我将顺序, 条件, 循环的部分整合出来

至于编译器是怎么充当这个桥梁的, 需要进入到builder的使用, 并且明白这个过程是非常重要的. 现在还不确切知道编译器在这个过程的工作细节, 但笔者认为可以先提出问题! 因为现在有目标: 要自定义顺序, 条件, 循环! 所以问swift:
1. 你怎么识别我写的代码是顺序的? 条件的? 循环的? 
2. 你识别了顺序,条件,循环的这些代码后, 只是单纯的swift语句, 怎么才算是我实现自定义? 
3. 即使我确实是在逻辑上自定义语言, 我的最终输出结果怎么得到?
4. 你怎么知道哪一块代码是DSL?(<font color = red>即DSL范围</font>)

笔者现在问了swift四个问题, 实际是向编译器作者提了4个问题.编译器作者然后根据这4个问题来修改swift本身, 让它具备识别顺序,条件,循环的功能, 并能和自定义的用户进行交互. 


### DSL入门
swift作者以协议的形式实现了DSL的功能流程, 所以基于已经实现好的swift, 便有了规定:
1. 使用`@resultBuilder`修饰enum, struct, class实现协议方法, 这些方法是顺序, 条件,循环的识别回调
2. 将实现协议的实体修饰给函数类型, swift便在该函数中启用DSL
    1. 函数
    2. 方法
    3. 计算属性的getter
    4. 下标的getter
    4. lambda

以顺序执行为例: 

```swift
@resultBuilder          // __code_register_builder
struct Builder {

    // __code_seq_cbk
    static func buildBlock(_ values: String...) -> String {
        values.joined()
    }
}


@Builder                // __code_modification
func build() -> String{
    "<"                 // __code_1
    "p"                 // __code_2
    ">"                 // __code_3
    "这是一个p标签"     // __code_4
    "<"                 // __code_5
    "/"                 // __code_6
    "p"                 // __code_7
    ">"                 // __code_8
}
print(build())          // <p>这是一个p标签</p>
```

代码流程:
1. `__code_regsiter_builder`: 注册DSL的回调, 这里使用struct Builder来实现协议方法
2. `__code_seq_cbk`: 注册顺序执行的回调函数
3. `__code_modification`: 启动DSL域, 即告诉编译器在build函数内部是自定义语言, 这对build函数有2点限制:
    - build内部的表达式返回值必须和buildBlock函数的参数类型是一致的, 这里是参数是`String...`, 所以表达式返回值也必须是String
    - build函数返回值必须和回调函数buildBlock一样是String
4. `__code_N`: 顺序书写的swift表达式, 每条表达式都返回了String, 这些返回值将被swift收集起来
5. 当build函数结束前, swift会将收集的8个表达式的结果整合成`String...`传递给buildBlock函数, 并将该函数的结果作为build函数的返回值
    - 这也是为什么build的函数返回值要和buildBlock保持一致的原因

> 开发中一般使用一个空枚举来定义DSL的回调函数, 这种枚举不允许创建对象, 所以相当于容器

上述代码相当于下面这张图:

--- 

<img src="./.image/013.png"/>

<a id="link-elephant"></a>

swift收集了每个表达式的结果, 然后创建了临时对象, 最后在函数返回前调用Builder.buildBlock. 这个过程看起来和自定义语言没任何关系! 来举一个案例: <font color = red>将大象放进冰箱</font>! 这是一个业务问题, 总共分3步:
1. 打开冰箱
2. 把大象放进去
3. 关闭冰箱

所有的编程语言(<font color = red>OOP</font>)都可以实现这个业务, 在swift中:

```swift
print("打开冰箱")
print("把大象放进冰箱")
print("关闭冰箱")
```

如果使用builder则变成了:

```swift
@resultBuilder
struct Builder {
    static func buildBlock(_ values: String){
        values.forEach {print($0)}
    }
}

@Builder
func build(){
    "打开冰箱"
    "把大象放进冰箱"
    "关闭冰箱"
}
```

从语法形式来看, 书写的格式只是写了3个字符串就实现了业务功能(打印), 所以可以看作是逻辑上的自定义



### buildBlock
前一小节的buildBlock是resultBuilder机制中必须实现的回调函数

```swift
static func buildFinalResult(_ component: ()) -> Result {} 
```

笔者对它的总结:
1. DSL域中的每个表达式会被赋值给临时对象
2. 在DSL结束前swift将收集到的这些临时对象整合成数组传递给该回调函数
3. 参数类型决定了DSL域中表达式返回的类型
4. 返回类型决定了DSL最终的返回值(<font color = red>未实现finalResult的情况</font>)
5. 可以使用泛型
6. 可以重载

```swift
@resultBuilder
struct Builder {
    static func buildBlock<T>(_ values: T...) -> String{
        values.description
    }
}

@Builder
func build() -> String{
    "<"
    "p"
    ">"
    "这是一个p标签"
    "<"
    "/"
    "p"
    ">"
}

print(build()) 
```

回调函数的参数类型是`T...`, 表示所有表达式的值必须为一种类型: 如全是Int, 或全是String等. 对于如下这种传递:

```swift

@Builder
func build() -> String{
    2               // error 2不是String类型
    "p"
    ">"
    "这是一个p标签"
    "<"
    "/"
    "p"
    ">"
} 
```
由于swift收集的结果中String的数量较多, 所以swift给出的报错体现在第1个整数2(<font color = red>2不是String类型</font>), 即swift认为T的类型是String, 数值2不是String. 但如下面这种调用:

```swift
@Builder
func build() -> String{
    2
    "p"             // error "p"不是整型
    ">"             // error ">"不是整型
    5
    5
    5
} 
```
即当前传递的整型数量较多, swift判断T的类型是整型, 所以表达式结果为String的将直接报错.  即使buildBlock可以重载, 但它所表示的意义可能并不是想要的

```swift
@resultBuilder
struct Builder {
    static func buildBlock(_ values: String...) -> String{
        return values.description
    }
    static func buildBlock(_ values: Int...) -> String{
        return values.description
    }
}


@Builder
func build(){
    "hello"
    20          
}
```

首先重载了buildBlock回调函数, 一个接收`String...` 一个接收`Int...`, 然后在DSL域(<font color = red>build函数</font>)中, 书写了2个表达式, 一个返回String, 一个返回Int, 编译器直接报错: <font color = red>找不到匹配的函数</font>, 因为收集的表达式结果不是统一的类型


<a id="link-demo-sql"></a>

### buildBlock案例
这里给出一个场景: 定义一个简单的SQL语句实现

> <font color = red>SELECT id frome user where id=20</font>

```swift
import os
import Foundation

protocol sql: CustomStringConvertible{}
extension sql { var description: String {"\(Self.self)".replacing("_", with: "")}}

protocol sql_literal: sql{}
protocol sql_variable<T>: sql where T: CustomStringConvertible{
    associatedtype T
    var variable: T {get set}
    init(_ value:() -> T)
}
extension sql_variable{
    var description: String {
        self.variable.description
    }
}


struct _SELECT_: sql_literal {}
struct _FROM_: sql_literal{}
struct _WHERE_: sql_literal{}
struct _AND_: sql_literal{}

struct _FIELD_: sql_variable {
    var variable: String = "*"
    init(_ value: () -> T) {
        variable = value()
    }
}

struct _VALUE_<E>: sql_variable where E: CustomStringConvertible{
    typealias T = E

    var variable: T

    init(_ value:() -> T) {
        variable = value()
    }
}

var SELECT  = _SELECT_()
var FROM    = _FROM_()
var WHERE   = _WHERE_()
var AND     = _AND_()

typealias FIELD     = _FIELD_
typealias TABLE     = _FIELD_
typealias VALUE     = _VALUE_
typealias CONDITION = _FIELD_

func ==<V> (_ field: FIELD, _ value: VALUE<V>) -> sql {
    CONDITION {field.description + "=" + value.description}
}

// 系统的 << 没有结合性, 这里添加一个左结合
precedencegroup M{
    assignment: true
    associativity: left
}
infix operator << : M

private func << (_ field: FIELD, _ other: @autoclosure () -> String) -> FIELD {
    FIELD {field.description + "," + other()}
}

@resultBuilder
struct Builder {
    static func buildBlock(_ values: sql...) -> String{
        return values.map(\.description).joined(separator:" ")
    }
}

@Builder
func build() -> String{
    SELECT

    FIELD { "id" }  << "name" << "age" << "city"

    FROM

    TABLE {"user"}

    WHERE

    FIELD {"city"} == VALUE {"北京"}

    AND

    FIELD {"age"} == VALUE {18}
}

print(build())      // SELECT id,name,age,city FROM user WHERE city=北京 AND age=18
```

1. demo中定义了sql的协议, 是一个模块的基协议. 遵循该协议的将会转变自己为字符串, 如`_SELECT_`将自己转换成`SELECT`, 它是sql中的关键字
2. 定义了sql中关键字的协议`sql_literal`, 所有sql的关键字将遵循它, 可以得到它们在sql中的字符串字面值
3. 定义了sql中变量的协议`sql_variable`,  它的任务是将在swift中存储sql语句中的变量部分
4. 定义各种select中要用到的部分关键字
    - select 
    - from 
    - where 
    - and
5. 为了做的像select, 笔者定义的类型是带下划线的, 然后再定义一个对应全局的只读对象, 目的是为了省去括号
6. 对于field部分重载了`<<`操作符, 第2个参数表示要搜索的字段. 
    - <font color = red>由于系统的`<<`没有结合性, 这里添加了左结合以保证可以不断连续使用它</font>
7. 对于where部分重载了`==`操作符, 是为了连接各种查询的条件

案例的缺点:
1. 做的足够简单, 没有将变量的部分以参数的形式传入
2. 为了做的像select, 额外定义了类型. 但这在swift中来说是必不可少的
3. where条件这里只定义了一个`==`, 事实上一个完整的select, where语句中有很多条件

> 这些缺点严格来说是可以慢慢实现的, 前提是得对select的语句十分精通, 同时封装成框架还要考虑效率, 可扩展性, 易用性等等


### 表达式不同类型
通过buildBlock的简单使用不难发现, 所有的表达式其实被无形限制了(<font color = red>被buildBlock的参数类型限制</font>), 这实际上就像笔者最开始所说, 不能在表达式之间插入无关的语句. 为了解决这种问题, swift给出的解决方案: 使用`buildExpression`对表达式先进行类型转换, 然后交给buildBlock函数

```swift
@resultBuilder
struct Builder {
    static func buildBlock(_ components: String...) -> String {
        components.joined(separator: "\n")
    }

    // 限制了DSL表达式中返回值, 但自己返回的类型必须和 buildBlock的String...对应上
    static func buildExpression(_ expression: Int) -> String {
        "0x" + String(expression, radix: 16)
    }
}

@Builder
func test() -> String{  // test函数的返回值要和buildBlock的返回值一样
    2024        // like: Builder.buildExpression(2024)
    10
    20
}
print(test()) 
```

demo中实现了另一个回调函数, 它被调用的优先级比buildBlock高, 表达式的返回值不再被buildBlock参数类型的限制, 而被buildExpression参数类型限制, 但被buildExperssion处理过后返回的类型必须为buildBlock函数参数的类型

### buildExpression的案例
这里做一个简单的录入信息

```swift
struct Human: CustomStringConvertible{
    var name: String = ""
    var age : UInt8 = 0
    var bir : String = ""
    var description: String {
        "(name:\(name), age: \(age), bir: \(bir))"
    }
}
struct Next{
    init(_ cbk: ()->String){
        print(cbk())
    }
}

@resultBuilder
struct Builder {
    static func buildBlock(_ components: Human?...) -> String {
        components.filter{$0 != nil}.map {$0!.description}.joined(separator: "\n")
    }
    static func buildExpression(_ expression: (name: String, age: UInt8, bir: String)) -> Human? {
        Human(name: expression.name, age: expression.age, bir: expression.bir)
    }
    static func buildExpression(_ expression: Next) -> Human? {
        nil
    }
}


let BUF_SIZE = 1024
var buf: UnsafeMutablePointer<CChar>! = UnsafeMutablePointer<CChar>.allocate(capacity: BUF_SIZE)
if buf == nil {
    fatalError("no memmory")
}
var buf_ptr = withUnsafeMutablePointer(to: &buf){$0}
var size = BUF_SIZE

func get_line(_ remind: String) -> String{
    print("\(remind):\n",terminator: "")
    // 返回读取内容的长度, 在测试中键入的内容是不会超过size的, 所以这里可以
    //  确定len是有效的
    let len = os.getline(buf_ptr, &size, os.stdin)
    if 0 >  len {
        os.perror("getline")
        os.exit(-1)
    }
    // 读取到eof, 当是标准输入时键入了 Ctrl+D后再键入Enter
    if 0 == len {
        os.exit(-1);
    }
    // getline会读取换行符, 这里去掉换行符
    buf!.advanced(by: len - 1).pointee = 0
    return String(cString: buf!)
}

let Name = {
    (arg: () -> String) -> String in
    get_line(arg())
}

let Age = {
    (arg: () -> String) -> UInt8 in
    UInt8(get_line(arg()))!
}
let Bir = Name


@Builder
func build() -> String{
    // (String, UInt8, String)
    (Name{"请输入姓名"},     Age {"请输入年龄"},  Bir {"请输入生日"})

    // (Next)
    Next {"**********************"}

    (Name{"请输入姓名"},     Age {"请输入年龄"},  Bir {"请输入生日"})
}

print(build())

buf.deallocate() 
```


### 修改返回类型
在builder机制里允许DSL的返回类型和buildBlock的返回类型不一致, 但要实现另一个回调函数<font color = red>buildFinalResult</font>, 它同时限制了:
1. DSL的返回类型必须和该函数的返回类型一致
2. buildBlock的返回类型必须和该函数的参数的类型一致

```swift
protocol 名: CustomStringConvertible {}
extension 名 {
    var description: String {
        "\(Self.self)"
    }
}

struct 铁矿: 名{
    init(_ 采矿: String){
        print("采矿得到:\(self)")
    }
}
struct 生铁: 名{
    init(_ 冶炼: 铁矿){
        print("冶炼:\(冶炼)")
    }
}
struct 钢: 名{
    init(_ 锻烧精炼: 生铁){
        print("锻烧精炼:\(锻烧精炼)")
    }
}

@resultBuilder
struct Builder {
    static func buildExpression(_ 采矿: String) -> 铁矿 {
        铁矿(采矿)
    }

    static func buildBlock(_ 所有铁矿: 铁矿...) -> [生铁] {
        所有铁矿.map { 生铁($0)}
    }

    static func buildFinalResult(_ 所有生铁: [生铁]) -> [钢] {
        所有生铁.map { 钢($0)}
    }
}


@Builder
func build() -> [钢]{   // 返回类型被 buildFinalResult限制
    "矿区采矿"      // 表达式的类型被 buildExpression限制
}

print(build()) 

#if false

采矿得到:铁矿
冶炼:铁矿
锻烧精炼:生铁
[钢]

#endif
```

这个demo体现了这3个函数的执行优先级, 就像炼铁的工序一样, 先调用的函数将结果交给下一个被调用的函数


### 依次回调每个表达式
buildBlock的机制是在函数返回前一次性将参数包装成`T...`被调用, swift还提供了2个回调函数来依次回调:

```swift
static func buildPartialBlock(first: T) -> T {}
static func buildPartialBlock(accumulated: T, next: T) -> T {} 
```

这两个函数的调用流程如下:

```swift
// 类型是Int

func build() -> Int {
    8
    7
    6
}

// 相当于
func build() -> Int {
    let tmp_local_0 = buildPartialBlock(first: 8)
    let tmp_local_1 = buildPartialBlock(accumulated: tmp_local_0, next: 7)
    let tmp_local_2 = buildPartialBlock(accumulated: tmp_local_1, next: 6)
    return tmp_local_2
}
func build()
```

这两个函数所影响的build的表达式类型比较复杂, 为了说明这个细节, 笔者这里定义几个名词:
1. TFirst: 表示first的类型
2. R1: 表示第1个函数的返回类型
3. TAccu: 表示accumulated的类型
4. TNext: 表示next的类型
5. R2: 表示第2个函数的返回类型

因为:
1. TAccu依赖于R1: swift回调第1个表达式得到的R1传递给第2个TAccu
2. TAccu依赖于R2, swift回调第2个, 第3个, 第4个, ... 表达式得到R2在下次传递给TAccu

所以结论:

1. `R1 == TAccu == R2`
2. TFirst任意类型, 至于它要不要转换为R1, 取决于第1个函数的实现
3. TNext任意类型, 至于它要不要转换为R2, 取决于第2个函数的实现
4. DSL函数的返回值必须和第2个函数的返回值保持一致


```swift
@resultBuilder
enum Builder{
    static func buildPartialBlock(first: String) -> Int {
        print("block first:\(first.self)")
        return Int(first)!
    }

    static func buildPartialBlock(accumulated: Int, next: String) -> Int {
        print("block next:<\(accumulated.self), \(next.self)>")
        return accumulated
    }
}

@Builder
@discardableResult func build() -> Int{
    "123"       // tmp_0 = (String) -> Int
    "hell"      // (Int, String) -> Int ===> tmp_1 = (tmp_0, "hell") -> Int
    3           // (Int, String) -> Int ===> tmp_2 = (tmp_1, 3) -> Int
                // 报错, 因为3不是String
} 
```

### 任意表达式类型
在只使用buildBlock回调函数时, 表达式的类型受到该函数参数类型的限制, 所有的表达式类型必须一致. 对于buildPartialBlock的定义可以指定泛型, 这样可以实现表达式的返回值是任意类型, 但是返回值类型必须为最后一条表达式的类型

```swift 
@resultBuilder
enum Builder{
    static func buildPartialBlock<T1>(first: T1) -> T1 {
        return first
    }

    static func buildPartialBlock<T2, T3>(accumulated: T2, next: T3) -> T3 {
        return next
    }
}
@Builder
@discardableResult func build() -> String{
    1 + 2 + 3
    "hello " + "nice " + "to " + "meet " + "u"
    (name: "tierry", age: 20)
    [2, "ehllo", (2, "jerry")] as [Any]
    ["name": "tom", "age": 20] as [String : Any]
    "return"
}
```

buildPartialBlock使用了泛型, 所以当产生调用时:
1. 第1次产生调用时: T1的类型是表达式`1 + 2 + 3`类型, 最后返回T1是Int
3. 第2次产生调用时: T2的类型被确定为Int, T3的类型是String, 返回T3是String
3. 第3次产生调用时: T2的类型被确定为String, T3的类型是Tuple, 返回T3是Tuple
4. 第4次产生调用时: T2的类型被确定为Tuple, T3的类型是Array, 返回T3是Array
5. 第5次产生调用时: T2的类型被确定为Array, T3的类型是Map, 返回T3是Map
6. 第6次产生调用时: T2的类型被确定为Map, T3的类型是String, 返回T3是String
7. 最终build函数返回的类型必须是最后一条表达式的类型

其实这种现象的原理就是:buildPartialBlock每次调用是独立的, 每次调用时, 泛型参数是独立的, 和上一次被调用时所传递的泛型参数没有任何关系. 根据这个机制, 可以直接修改前面的[sql案例](#link-demo-sql)

```swift
@resultBuilder
enum Builder{
    static func buildPartialBlock<T1>(first: T1) -> T1 {
        return first
    }

    static func buildPartialBlock<T2, T3>(accumulated: T2, next: T3) -> String {
        return "\(accumulated) \(next)"
    }
}
@Builder
@discardableResult func build() -> String{  // 返回值要和最后一条语句一致
    "SELECT"
    "*"
    "FROM"
    "user"
    "WHERE"
    "id = \(3)"
} 
```

这个demo相对来说就简洁多了




### 单个if的自定义
通过DSL顺序执行的机制, 目前已经清楚了builder的基本原理, 但实际自定义的语言中条件执行是必不可少的. 为了理解条件实现的流程细节, 笔者先从单个if开始探究. 如果在DSL中书写了一个单独的if语句, 则必须实现如下回调:
```swift
static func buildOptional(_ component: T?) -> R
```

> 返回值的类型由用户自己定义, 也可能返回可选

单个if语句块一定回调该函数. 只是传递的参数可能为nil:
1. 当if的条件为false时, swift直接回调该函数并传递nil
2. 当if的条件为true时,  swift的机制是:
    1. if条件中的每个表达式赋值到临时对象
    2. if语句块结束前, 调用buildBlock函数, 将收集到的所有临时对象传递进去
    3. 获取buildBlock的返回值, 并调用buildOptional, 参数为buildBlock的返回值
3. 将buildOptional的返回值赋值给临时对象tmp1
4. 最终tmp1会被收集在外层的临时对象集合中, 在DSL域结束前调用buildBlock函数用到它

以下面的demo来实, 共产生了2次buildBlock的调用


```swift
extension Optional {
    var ok: Bool {self != nil}
}

@resultBuilder
enum Builder{
    static func buildBlock(_ components: String? ...) -> String {
        (components.filter(\.ok) as! [String]).joined(separator: " ")
    }
    static func buildOptional(_ component: String?) -> String? {
        component
    }
}

@Builder
func build(_ flag: Bool) -> String{
    "tierry"        
    "is"            
    "work"          
    if flag {       
        "in"        
        "hubei"     
    }
}
print(build(true))  // tierry is work in hubei
```

该函数的调用类似下图:

---

<img src="./.image/014.png"/>

> 白色的部分相当于编译器添加的代码


swift在收集了if条件中的结果后, 是直接调用buildBlock函数, 并不会先调用buildExpression:

```swift
// 在Builder中添加buildExperssion的回调
@resultBuilder
enum Builder{
    ...

    static func buildExpression(_ expression: String...) -> String {
        expression.first!
    }
}

@Builder
func build(_ flag: Bool) -> String{
    "tierry"        // tmp_0 = buildExpression("tierry")
    "is"            // tmp_1 = buildExpression("is")
    "work"          // tmp_2 = buildExpression("work")

    // tmp_3: String?
    if flag {
        "in"        // tmp_3_0 = buildExpression("in")
        "hubei"     // tmp_3_1 = buildExpression("hubei")
                    // tmp_3_2 = buildBlock(tmp_3_0, tmp_3_1)
                    // tmp_3   = buildOptional(tmp_3_2)
    }   // __code 

    // else {
    //      tmp_3 = buildOptional(nil)
    // }
} 
```

> 在`__code`这里, swift并不会再次将`tmp_3`传递给buildExpression, 而是直接调用buildBlock.

从测试的过程可以发现, swift并不要求用户明确写出else的子语句, 但幕后处理时, swift会自动生成buildOptional(nil)的调用. 笔者认为生成else的语句其实不是必须的(<font color = red>用户在DSL中只写一个if的背后逻辑是else不做任何处理, 所以从这一点看笔者认为没有必要做这一步的操作</font>). 但SwiftUI需要这样的默认处理, 它需要在默认else的情况下生成View以使幕后的视图层级相对来说是稳定的(<font color = red>后续会详细学习</font>), 这样的目的是提高渲染的性能 





### 有else的分支
当用户明确写出了else语句:
1. `if--else`
2. `if--else if--else if -- ... --else`: 无限嵌套
3. `switch case`

swift给出了2个回调函数来处理有else的所有情况

```swift
// 第1个if成立时被回调
//  所有if系列处理完毕后, 在逻辑上相当于还有
//      一个else没处理, 编译器会再次调用first
static func buildEither(first component: String) -> String {
    component
}

// 其他书写的条件语句来这里
static func buildEither(second component: String) -> String {
    component
} 
```

first有2种调用时机:
1. 第1个if成立时
2. 默认的else处理

```swift
@resultBuilder
enum Builder{
    static func buildEither(first component: String) -> String {
        print("first")
        return component
    }
    
    static func buildEither(second component: String) -> String {
        print("second")
        return component
    }
    static func buildBlock(_ components: String? ...) -> String {
        print("block")
        return (components.filter(\.ok) as! [String]).joined(separator: " ")
    }

    static func buildOptional(_ component: String?) -> String? {
        print("optional")
        return component
    }
}

@Builder
func build(_ flag: Int) -> String{
    if flag == 0{
        "1"                     // tmp_0 = block("1") --> tmp_0 = first(tmp_0)
    }else if flag == 1 {
        "2"                     // tmp_0 = block("2") --> tmp_0 = first(tmp_0)
    }else{
        "3"                     // tmp_0 = block("3") --> tmp_0 = first(tmp_0)
    }
                                // 上述只有1个会成立, 所以在逻辑上相当于还有一个else未处理, 
                                // 类比buildOptional, 编译器会默认添加一个调用, 但这个调用函数为: first,
                                //  即使定义了buildOptional也是回调first
                                // tmp_0 = first(tmp_0)
                                //  所以first被回调了2次
    //return block(tmp_0)
}
print(build(0)) 
#if false
block
first
first
block
1
#endif



print(build(1))
#if false
block
second
first
block
2
#endif

print(build(3))
#if false
block
second
first
block
3
#endif
```

> switch的分支语句本质和if是一样的

### 没有else的分支
当书写的格式中没有else时:
1. 单个if
2. `if--else if-- ... --else if`

这个时候必须给出buildOptional的自定义, 在逻辑上未处理的else将回调到buildOptional

```swift
@resultBuilder
enum Builder{
    static func buildEither(first component: String) -> String {
        print("first")
        return component
    }
    
    static func buildEither(second component: String) -> String {
        print("second")
        return component
    }
    static func buildBlock(_ components: String? ...) -> String {
        print("block")
        return (components.filter(\.ok) as! [String]).joined(separator: " ")
    }

    static func buildOptional(_ component: String?) -> String? {
        print("optional")
        return component
    }
}

@Builder
func build(_ flag: Int) -> String{
    if flag == 0{
        "1"
    }else if flag == 1 {
        "2"
    }
}
print(build(1)) 

#if false
block
second
optional
block
2
#endif
```

> 当用户书写出`else if`的分支时, 也必须同时提供`second`的回调

### 版本限制下的if
在iOS的开发中常常一些API可能不适用于低版本的环境中, 通常会在代码中作版本判断:`if #avaiable(iOS 15, *)` 表示在`iOS 15` 以后可用, 如下面的测试:

```swift
@available(macOS 18, *)
struct Str: CustomStringConvertible{
    var description: String{
        "he"
    }
}

print(Str())        // __code_error


if #available(macOS 18, *) {    
    print(Str())
} else {
    // Fallback on earlier versions     // __code_exec
}
```

测试时笔者系统版本是`MacOS 15.0.1`, 代码中的`__code_error`将会在编译期直接报错, 将`__code_error`注释, 然后测试, 最终代码if进入了`__code_exec`. 如果要在DSL中书写出这样的单个if语句, swift是这样的处理流程:
1. 如果未实现buildLimitedAvailiablity时, 处理流程和单个if的过程一样
    - block
    - optional
    - block
2. 若1不成立 并且 if 不成立:
    - optional
    - block
3. 若1不成立 并且 if 成立:
    - block
    - availability
    - optional
    - block


```swift
extension Optional {
    var ok: Bool {self != nil}
}


@resultBuilder
enum Builder{
    static func buildEither(first component: String) -> String {
        print("first")
        return component
    }
    
    static func buildEither(second component: String) -> String {
        print("second")
        return component
    }
    static func buildBlock(_ components: String? ...) -> String {
        print("block")
        return (components.filter(\.ok) as! [String]).joined(separator: " ")
    }

    static func buildOptional(_ component: String?) -> String? {
        print("optional")
        return component
    }

    static func buildLimitedAvailability(_ component: String) -> String {
        print("availiablity")
        return component
    }
}

@Builder
func build() -> String{
    if #available(macOS 15, *) {
        "1"         // tmp_0 = block("1") 
                    // tmp_0 = availability(tmp_0) 
    }               
    // else {
    //      tmp_0 = optional(tmp_0)
    // }

    // return block(tmp_0)
}
print(build())     // 对应第3条
```

如果用户明确书写了`else`:

```swift
@Builder
func build2() -> String{
    if #available(macOS 15, *) {
        "1"         // tmp_0 = block("1")
                    // tmp_0 = availability(tmp_0)
    }else {
        "2"
    }

    // else {
    //      tmp_0 = first(tmp_0)
    // }

    // return block(tmp_0)
}
print(build())
```

### 嵌套的条件语句
当在DSL书写过多的嵌套条件时, swift的处理逻辑没有变. swift会以堆栈的形式尝试分解所有的条件语句, 从最里层往外依次回调

```swift
@resultBuilder
enum Builder{
    static func buildBlock(_ components: String ...) -> String {
        print("block")
        return components.joined(separator: " ")
    }

    static func buildOptional(_ component: String?) -> String {
        print("optional")
        return component ?? "nil"
    }

}

@Builder
func build(_ num: Int) -> String{  // num = 3
    if num > 0 {            // true
        
        if num > 5 {        // false
            "5"             
        }                   // tmp_0 = optional(nil) = "nil"

        if num > 2 {        // true
            "2"             // tmp_1 = block("2") = "2"
                            // tmp_1 = optional(tmp_1) = "2"
        }                   

        //  此刻整个if的代码相当于
        //      if num > 0 {
        //          tmp_0 = "nil"
        //          tmp_1 = "2"
        //      }
        //  即已经回调产生了 tmp_1, 要跳出 if num > 0 的作用域了, 所以在跳出之前:
        //      tmp_2 = block("nil", "2") = "nil 2"
        //      tmp_2 = optional(tmp_2) = "nil 2"
        //  最后出了作用域, 整个函数中的if完毕, 要再将次所有的结果交给block:
        //      return block(tmp_2)   "nil 2"
    }
}
```

### 局部作用域
在DSL中书写的代码如果是在作用域中, 也会导致回调的顺序发生改变.

```swift
@resultBuilder
enum Builder{
    static func buildBlock(_ components: String ...) -> String {
        print("block")
        return components.joined(separator: " ")
    }

    static func buildOptional(_ component: String?) -> String {
        print("optional")
        return component ?? "nil"
    }

}

@Builder
func build() -> String{
    do {
        "2"     // tmp_0 = block("2")
    }           

    // 将结束函数, 将收集到的所有临时对象交给block
    return block(tmp_0)
}

@Builder
func build2() -> String{
    do {
        if true {
            "2"     // tmp_0 = block("2")
        }           // tmp_0 = optional(tmp_0)

        // tmp_0 = block(tmp_0)
    }

    // return block(tmp_0)
}


@Builder
func build3(_ num: Int) -> String{  // num == 3
    if num > 0 {            // true

        do {
            if num > 5 {    // false
                "5"     
            }               // tmp_0 = optional(nil) = "nil"

            if num > 2 {    // true
                "2"         // tmp_1 = block("2")
                            // tmp_1 = optional(tmp_1)
            }

            tmp_2 = block(tmp_0, tmp_1) = "nil 2"
        }
        tmp_3 = block(tmp_2) = "nil 2"
        tmp_4 = optional(tmp_3) = "nil 2"
    }

    return block(tmp_4)
}
```


### 循环自定义
swift中的循环格式有多种, 但在DSL中只允许for循环格式的存在. 

```swift
@resultBuilder
enum Builder{
    static func buildBlock(_ components: String ...) -> String {
        print("block")
        return components.joined(separator: " ")
    }

    static func buildExpression(_ expression: Int) -> String {
        print("expression")
        return String(expression)
    }

    static func buildArray(_ components: [String]) -> String {
        print("array")
        return components.joined(separator: "-")
    }
}

@Builder
func build2(_ num: Int) -> String{
    for i in 0...num {
        i   
            // 0:  tmp_0 = expression(0)
            //     tmp_0 = block(tmp_0)

            // 1:  tmp_1 = expression(1)
            //     tmp_1 = block(tmp_1)

            // 2:  tmp_2 = expression(2)
            //     tmp_2 = block(tmp_2)

            // 3:  tmp_3 = expression(3)
            //     tmp_3 = block(tmp_3)

        // array即将结束, 这一点和条件不一样, swift优先调用array, 传递的参数是数组, 并不是可变参数
        //  tmp = array([tmp_0, tmp_1, tmp_2, tmp_3])
    }

    return block(tmp)
}

print(build2(3)) 
```


### 嵌套循环
当出现嵌套循环时, <font color = red>swift的作法是先计算最内层的循环, 再往外整合</font>

```swift
@resultBuilder
enum Builder{
    static func buildBlock(_ components: String ...) -> String {
        print("block")
        return components.joined(separator: " ")
    }

    static func buildExpression(_ expression: Int) -> String {
        String(expression)
    }

    static func buildArray(_ components: [String]) -> String {
        print("array")
        return components.joined(separator: "-")
    }
}

@Builder
func build2(_ num: Int) -> String{  // num = 3
    for i in 1...num {      
        i                           // __code_i
        for j in 1 ... 2 {
            j                       // __code_j
        }

                                    // i: 1
                                    //  __code_j:   tmp_j_1 = block(1) = "1"
                                    //              tmp_j_2 = block(2) = "2"
                                    //              tmp_j   = array([tmp_j_1, tmp_j_2]) = "1-2"
                                    //  出第2层for作用域后
                                    //              tmp_1 = block(i, tmp_j) = "1 1-2"

                                    // i: 2
                                    //  __code_j:   tmp_j_1 = block(1) = "1"
                                    //              tmp_j_2 = block(2) = "2"
                                    //              tmp_j   = array([tmp_j_1, tmp_j_2]) = "1-2"
                                    //  出第2层for作用域后
                                    //              tmp_2 = block(i, tmp_j) = "2 1-2"
                                    

                                    // i: 3
                                    //  __code_j:   tmp_j_1 = block(1) = "1"
                                    //              tmp_j_2 = block(2) = "2"
                                    //              tmp_j   = array([tmp_j_1, tmp_j_2]) = "1-2"
                                    //  出第2层for作用域后
                                    //              tmp_3 = block(i, tmp_j) = "3 1-2"


                                    // 即将出第1层for, 调用array
                                    //  tmp_4 = array([tmp_1, tmp_2, tmp_3) = "1 1-2-2 1-2-3 1-2"
    }

    // return block(tmp_4)
}

print(build2(3)) 
```

### 声明式编程
在编程领域常常听到指令式编程和声明式编程2种概念. 直观上来看这2种编程模式存在于代码形式上, [大象放进冰箱](#link-elephant)中, 使用了DSL自定义, 在书写形式上只关注了这个业务的3个功能, 所以直接顺序写出了3个字符串. 若以指令式来实现, 大致是:

```swift
// 大象
struct Elephant {}

// 冰箱
struct Refrigerator{
    func open(){print("打开冰箱")}
    func input(e:inout Elephant){print("把大象放进冰箱")}
    func close(){print("关闭冰箱")}
}

// 定义一个大象
var e = Elephant()

// 定义一个冰箱
let r = Refrigerator() 

// 打开冰箱
r.open()

// 将大象放进冰箱
r.input(e: &e)

// 关闭冰箱
r.close()
```

使用DSL就会简化这个过程, 大象放冰箱的DSL就相当于声明式编程的思想. 所谓声明式编程原则上只关注业务功能的结果, 不追求实现细节, 这个细节由专门的框架来实现. 如SwiftUI框架, 它使用DSL简化了苹果环境下UI布局的开发, 用户只需要告诉SwiftUI需要什么布局控件, 不需要刻意指定排版, 位置, 尺寸等等, 这些状态由SwiftUI自行管理. 所以使用SwiftUI的过程本身就是定制组合布局控件的过程. 



### SwiftUI的原理(<font color = red>简介</font>)
SwiftUI是苹果新的UI框架, 它使用swift语法编写, 目标是为了取代UIKit[^ann-uikit]. SwiftUI使用起来比较简洁, 它是典型的声明式语法(<font color = red>DSL</font>), 通过`@ViewBuilder`将结果构造为视图层级结构, 即用户在DSL中书写的语句会被它整合成特定高效的视图结构, 这个结构由SwiftUI在幕后维护. 关于它具体的实现将在SwiftUI的章节中详细探究


### 终止DSL
在DSL域中整个过程由swift来主导, 正常情况下必须执行完整个DSL域后才被block返回(<font color = red>未实现finalResult</font>), 即用户没有明确指定return语句. 但是当指定return语句后除了返回当前函数外, 也表示终止DSL

```swift
@resultBuilder
enum Builder {
    static func buildBlock(_ components: Int...) -> Int {
        2
    }
}


@Builder
func test(flag: Bool) -> Int{
    // 指定了if语句, 但同时指定了return语句,
    //  所以即使Builder中未实现 buildOptional的回调函数也不会报错,
    //  编译器会将当前函数当成普通函数, 相当于向编译器表示该函数不是DSL
    if flag {
        return 100      
    }
    return -100
}

print(test(flag: false))
```




### macro的概念
要讨论swift下的宏(<font color = red>macro</font>), 就要先了解C语言下的预编译. 在C语言中预编译阶段在正式编译源代码之前, 这个阶段主要的工作是执行所有的预编译指令. 预编译指令一般以`#`开头, 如:
1. `#include`
2. `#define`
3. `#if`
4. `#pragma`

笔者常说的macro就是`#define`这条预编译指令. macro的原理是预编译阶段的等价替换. 总结起来:
1. 不是C标准的部分, 各厂家编译器对macro的实现和展开有些许差异
2. 展开的过程没有语法检查
    - 利用宏实现的表达式相当于inline函数
    - 定义宏的过程不会有C语法的检查
    - 预编译完成以后, 编译源代码时才会做语法检查
3. 因为是等价替换, 所以展开的过程可能有陷阱
4. 非常灵活

C语言中的macro可以实现很多匪夷所思的功能, 甚至改变书写语法(<font color = red>简单的语言扩展</font>),macro的效率是最高的(<font color = red>C++中可变模板底层算法也是macro的原理</font>). macro在使用上需要很高的技巧性, 由于没有类型检查对待用户不很友好(<font color = red>笔者并不认为这是一种缺点</font>). 能够灵活运用macro的程序员一定是有个性且爱折腾追求创新的. 后续笔者并不会过多阐述C环境下的macro

swift`5.9`之前没有自定义macro的功能, 但swift提供了有很多关键字能够帮助用户生成繁复的代码, 其实这就是宏的功能(<font color = red>macro存在的意义就是生成代码</font>), 只不过不可定制. 诸如:
1. `@propertyWrapper`: 它告诉编译器生成固定的代码
2. `@resultBuilder`:  它也是告诉编译器在DSL域中生成调用回调函数的代码
3. `@OptionSet`: 标准库实现的bit位枚举(<font color = red>`6.0`已经删除</font>)

swift`5.9`公开了编译器的接口(SwiftSyntax), 允许用户扩展swift语法同时不改变编译器原有的功能. 


### swift中的macro
swift中的macro整体来说并不是C语言的继承, 它向用户公开了语法操作的接口, 从理论上来讲相当于语法扩展, 但还是受限于swift本身. 实现的扩展部分还是swift语句!! 其实这是符合逻辑的, 因为就算是C语言中的macro最终也是回归到C语言本身. 相比于C语言, swift中的macro优势:
1. 宏本质是swift的库, 定义过程就是在书写swift语句, 整个过程有语法检查, 所以编写比较方便
2. 宏展开是在编译期. 对宏的调用也有swift的语法检查, 就像在调用库一样
3. 宏可以实现重载, 泛型
4. 宏可以自由定制语法, 并且定制的过程很容易, 所以比C语言中的宏更强大
5. 宏可以与源码中的对象同名, 因为宏的调用方式可以区分开普通对象
    - C语言对象若和宏同名将改变对象的性质

但它同时也存在缺点:
1. 使用门槛较高
    - 要理解macro和编译器的工作流程
    - 要理解swift语法树相关的知识, 结构, 和使用
2. 不能直接定义 <font color = red>半成品</font>
    - C语言中的macro之所以强大, 是因为macro在定义时不受语法限制, 定义一个半成品的macro, 然后再配合书写补全可以达到匪夷所思的功能    

swift中的宏也可以定义半成品, 但没有C语言那样直观:

---

<img src="./.image/022.png"/>

<br/>

如该图这是在C环境下利用宏封装`async-await`的语法. 其实在swift中也可以实现这种效果, 但并没有这样直观: 一方面是因为宏调用格式; 另一方面是宏的参数受语法检查不能直接传递字面量, 必胜传递字符串, 所以显得不直观. 就类似于:

```swift
@Async("id", "result") = @Await func(a, b) 
```


### swift中macro机制
swift中的macro不直接由编译器处理, 而是由扩展的编译插件处理. 具体来说:
1. swift遇到外部的macro
2. 调用这个macro的编译插件
3. 编译插件处理完后将结果返回给swift
4. swift将得到的结果做展开, 然后继续编译

这整个过程由swift编译器主导, 所谓的编译插件只不过是swift语言编写的库, 这种库并不是开发中的业务代码, 而是依赖SwiftSyntax. 因为整个macro的展开过程就是在编译期, 所以最终的可执行文件中并没有插件库, 也不会存在原始的macro代码(<font color = red>全部是展开后正确的swift代码</font>)

总结就是: 可以不使用macro来开发swift, 但使用macro可以更加精减代码

### macro的种类
共有2种形式的macro, 它们调用的格式:
1. 以`#`开头调用的macro表示独立宏, 它不被其他任何如对象,类型,属性等约束. 它们的功能是在调用点展开代码. 
2. 以`@`开头调用的macro表示附加宏, 它们要依赖于其他诸如对象,类型,属性,方法,函数等, 不可单独存在. 它们的功能是为所修饰的元素附加额外的属性, 如:
    - 修饰struct时添加方法, 属性(任意属性)
    - 修饰函数时添加参数形成重载

|macro|值类型|说明|
|:-:|:-:|:-|
|`#line`|整型字面量|行号|
|`#filePath`|字符串字面量|当前文件绝对路径|
|`#fileID`|字符串字面量|swift生成的唯一标识, 一般是文件名|
|`#file`|字符串字面量|一般是文件名|
|`#function`|字符串字面量|当前函数名(<font color = red>包括闭包,计算属性,下标等</font>)|


### macro的开发流程
因为macro本质是swift语言开发的库, 所以需要在特定的环境下进行开发测试. 

---

<img src="./.image/015.png"/>

<img src="./.image/016.png"/>

<img src="./.image/017.png"/>

<img src="./.image/018.png"/>

<img src="./.image/019.png"/>


--- 

上述流程是自定义macro的环境, 当工程初始化后有这样几个文件:
1. `main.swift`: 该文件是在当前环境下使用自定义的macro, 相当于在一个业务工程中导入宏所在的模块然后使用它
2. `LBMacro.swift`: 宏的声明文件
3. `LBMacroMacros.swift`: 宏的实现文件
4. `LBMacroTest.swift`: 在当前环境下测试宏展开是不是对的


在任何地点使用一个测试好的宏时, 可以`鼠标-->右键-->Expand Macro`, 以查看宏的展开是不是符合预期

---

<img src="./.image/020.png"/>
<img src="./.image/021.png"/>

---


### stringify
初始化好工程后, Xcode默认实现了一个stringify的独立宏, 该宏的功能:

```swift
let a = 17
let b = 25

let (result, code) = #stringify(a + b)

/// 展开成
let (result, code) = (a + b, "a + b")
```

现在来测试一下这个宏:
1. 操作stringify的结果, 如看能不能调用tuple相关操作
2. 向其传入一个非法的表达式
3. 尝试使用组合书写

```swift
// 直接对macro生成的结果(tuple)进行操作
let value = #stringify(a + b).0     // 42
let key   = #stringify(a + b).1     // "a + b"


// swift直接在编译期报错(非法的表达式)
//#stringify(a + )

func f<T>(_ number: T, _ des: String) {}

// 这里的目的是想生成如下的代码:
//      f (a + b, "a + b")
//  产生函数调用, 但这里直接报错
f #stringify(a + b) 
```

为了对比这里给出C语言中的macro表现

```cpp
void f(int number, const char* key){
    printf("f被调用(%d, %s)", number, key);
}

// #_expr, C字符串化键入的字面字符串
//  abc ==> "abc"
//  a + b ==> "a + b"
#define stringify(_expr) ((_expr), #_expr)

int main(void){
    const int a = 17, b = 25;
    f stringify(a + b) ;
    
    // 展开成
    f ((a + b), "a + b") ;  // 通过键入的 f 和 stringify(a + b) 组合成正确的表达式
    return 0;
}
```

也就是说stringify不能实现这种组合表达, 因为它本质是swift表达式, 其展开的结果也是表达式, 并不是键入的字面量字符串. 综合这一点它只可以使用在表达式该出现在的地方. 


### stringify实现
在初始化的工程中, stringify的声明和实现是分开的.

```swift
// LBMacro.swift: 声明
@freestanding(expression)
public macro stringify<T>(_ value: T) -> (T, String) = #externalMacro(module: "LBMacroMacros", type: "StringifyMacro")
```

1. `@freestanding`: 表示stringify是一个独立宏
2. `expression`: 表示它的角色是表达式, 这对它有两个限制:
    1. 只能替换某个表达式, 同时决定了它只用在表达式出现的地方
    2. 替换后的结果必须是表达式
3. `public`: 所有的宏应该定义成public, 公开所有的访问权限(<font color = red>这只是一种约定</font>)
4. `macro`: 声明宏的关键字
5. `<T>`: stringify接收表达式时, 该表达式的结果可以是泛型, 最终stringify会生成新的表达式tuple
6. `=`: stringify实现所在的模块和实现
7. `#externalMacro`: 指明stringify是一个外部宏, 外部宏相当于编译扩展, 所以会生成编译器插件
8. `module`: 外部宏的参数, stringify实现所在的模块
9. `type`: 外部宏的参数, stringify实现者(<font color = red>只是方法的容器</font>)

这个声明将来被导入到用户模块时, 可以查看到, 相当于C语言中的头文件, 当swift遇到`#stringify(a + b)`时:
1. 查看该声明
2. 启动沙盒进程调用`LBMacroMacros.StringifyMacro`的实现
3. 将`a + b`封装成SwiftSyntax相关的结构(<font color = red>语法树</font>)传递给实现函数
4. 函数最终会返回处理好的tuple表达式给swift
5. swift拿到编tuple后就地展开, 然后继续编译

```swift
import SwiftCompilerPlugin      // 生成编译器插件
import SwiftSyntax              // 语法树, 最核心的结构(极其复杂)
import SwiftSyntaxBuilder       // 语法树结点的DSL构造者, 通过它可以直接使用字符串插值(swift语句)构建语法树结点
import SwiftSyntaxMacros        // 自定义宏实现时, 不同角色的宏需要遵循的协议

// LBMacroMacro.swift: 宏的实现
public struct StringifyMacro: ExpressionMacro { // __code_expr_protocol
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax, // __code_expr_syntax
        in context: some MacroExpansionContext          // __code_context
    ) -> ExprSyntax {                                   // __code_return_expr

        // __code_guard
        guard let argument = node.arguments.first?.expression else {
            fatalError("compiler bug: the macro does not have any arguments")
        }

        // __code_ctor_tuple
        return "(\(argument), \(literal: argument.description))" 
    }
}


// 注册到编译器插件中
@main
struct LBMacroPlugin: CompilerPlugin {
    let providingMacros: [Macro.Type] = [
        StringifyMacro.self,   //编译器会调用该函数生成编译器插件库
    ]
}
```

1. `__code_expr_protocol`: 实现者遵循表达式宏的协议, 这也同时对应了声明`@freestanding(exression)`
2. 函数expansion是需要实现的协议函数, 当swift在代码中遇到`stringify(a + b)`时会回调到这里来
3. `__code_expr_syntax`: swift回调时先封装`a + b`为语法树对象, 这个对象对应了stringify的角色, 在回调函数里可以拿到这个对象, 然后获取相关的信息, 如:
    - 表达式对象中参数的个数
    - 表达式的描述
4. `__code_context`: 和编译器通信的上下文, 可以利用它进行编译器级别的报错
5. `__code_return_expr`: 函数要返回的类型, stringify的声明决定了它必须返回一个swift表达式, 而它对应的结构就是ExprSyntax
    - swift中所有表达式有固定的类型, 如tuple为TupleExprSyntax, 这里使用ExprSyntax可以接收任意swift表达式
6. `__code_guard`: 根据swift构造的Syntax结点查看一下是否有表达式, 如果没有则stringify处理不了, 则直接报错
    - 报错时直接使用了fatalError函数, 该函数将直接结束当前的沙盒进程
    - 报错显示的错误信息会交给swift, swift在调用点`#string(a + b)`直接将错误展开
7. `__code_ctor_tuple`: 直接利用字符串插值构造tuple表达式

> PS: SwiftSyntax(<font color = red>AST</font>)是一个极其复杂语法解析器, 它是swift编译器的内核一部分. 笔者目前没有能力讨论这些东西.


### stringify参数信息
当swift编译到`#stringify(a + b)`时:
1. 因为stringify是一个独立宏, 并且`#stringify(a + b)`的调用格式符合它的声明, 所以决定调用插件实现`LBMacroMacros.StringifyMacro`
2. 在调用前生成语法树结点, 并传递给实现的第1个参数
3. 创建上下文, 并传递给实现的第2个参数

可以利用测试模式, 在实现的函数打上一个断点, 然后利用lldb查看一下node(结点)的结构.

```swift
// 上下文, 这是工程提供的测试样例
func testMacro() throws {
    #if canImport(LBMacroMacros)
    assertMacroExpansion(
        """
        #stringify(a + b)
        """,
        expandedSource: """
        (a + b, "a + b")
        """,
        macros: testMacros
    )
    #else
    throw XCTSkip("macros are only supported when running tests for the host platform")
    #endif
}


public struct StringifyMacro: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) -> ExprSyntax {

        // __lldb_breakpoint

        guard let argument = node.arguments.first?.expression else {
            fatalError("compiler bug: the macro does not have any arguments")
        }
        return "(\(argument), \(literal: argument.description))"
    }
}


MacroExpansionExprSyntax                            // 代码中书写的 #stringify(a + b) 确实是宏表达式(@freestanding(expression))
├─pound: pound
├─macroName: identifier("stringify")                // 宏名是 stringify
├─leftParen: leftParen                              // 左括号  (
├─arguments: LabeledExprListSyntax                  // 参数表达式信息, 是一个数组(只有1个元素)
│ ╰─[0]: LabeledExprSyntax                          //  第0个元素:标签表达式
│   ╰─expression: InfixOperatorExprSyntax           //      表达式类型是: 中缀表达式
│     ├─leftOperand: DeclReferenceExprSyntax        //          左操作数: 声明表达式
│     │ ╰─baseName: identifier("a")                 //              左操作数的名字: a
│     ├─operator: BinaryOperatorExprSyntax          //          中缀操作符类型: 2元操作符
│     │ ╰─operator: binaryOperator("+")             //              中缀操作符: +
│     ╰─rightOperand: DeclReferenceExprSyntax       //          右操作数类型: 声明表达式
│       ╰─baseName: identifier("b")                 //              右操作数的名字: b
├─rightParen: rightParen                            //  右括号 )
╰─additionalTrailingClosures: MultipleTrailingClosureElementListSyntax 
```

观察可以发现回调函数中argument的取值流程完全是按照结点的层次结构依次取出的, 也就是说: <font color = red>FreestandingMacroExpansionSyntax的内存布局就是lldb中打印的结点结构</font>, 根据这种对应关系, 其实实现的代码可以修改成:

```swift
// let op = argument as!  InfixOperatorExprSyntax       // error, 不能直接转换

let op = InfixOperatorExprSyntax(argument)  // __code_0
// 或
// let op = argument.as(InfixOperatorExprSyntax.self)

if let op {
    let arg_0 = op.leftOperand              // __code_1
    let op_id = op.operator                 // __code_2
    let arg_1 = op.rightOperand             // __code_3

    // __code_4
    //let result = ExprSyntax("(\(arg_0) \(op_id) \(arg_1), \"\(arg_0) \(op_id) \(arg_1)\")")

    // __code_5
    let result = ExprSyntax("(\(arg_0) \(op_id) \(arg_1), \(literal: arg_0.description)+\(literal: op_id.description)+\(literal: arg_1.description))")
    return result
} 
```

由于目前测试的表达式是最简单的, 只传递了`a + b`, 不要考虑复杂的情况(如`a + b + c)`), 这个测试的目的: <font color = red>将回调的参数进行参数转换来获取表达式中的信息</font>. 笔者先给出一个总结: 不能直接转换argument对象, 会发生运行时错误, 所以笔者直接使用`__code_0`来通过argument对象构造一个中缀表达式
1. `__code_0`: 使用argument构造`a + b`的SwiftSyntax结构
2. `__code_1`: 取出语法结构中的左操作数, 从lldb中可以知道它是`DeclReferenceExprSyntax`
3. `__code_2`: 取出中缀表达式的运行符`+`, 它的类型是`BinaryOperatorExprSyntax`
4. `__code_3`: 同理取出右操作数
5. `__code_4`: 第1种形式构造tuple
6. `__code_5`: 第2种形式构造tuple

构造tuple的过程将在下小节给出



### stringify在返回时插值
笔者不了解SwiftSyntax, 这里只能根据默认stringify的返回来进行探究. 

```swift
public struct StringifyMacro: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) -> ExprSyntax {
        // 判断表达式的类型是否是有效的
        guard let argument = node.arguments.first?.expression else {
            fatalError("compiler bug: the macro does not have any arguments")
        }
        return "(\(argument), \(literal: argument.description))"
    }
} 
```

stringify向外声明的是返回一个`tuple(Int, String)`表达式, 但它实现的协议函数要求返回一个ExprSyntax. 函数中使用字符串插值构造了该类型的对象. 这个过程实际由SwiftSyntaxBuilder模块中的SyntaxStringInterpolation完成, 它实现了ExpressibleByStringInterpolation(<font color = red>插值协议</font>), 所以用户可以直接使用插值来间接构造ExprSyntax对象. 有3种插值方式:
1. `"\(SwiftSyntax)"`: 直接给一个SwiftSyntax对象, 最终原样输出.  
    ```swift
    // 原始信息为 a + b
    // 构造信息为 a + b
    //  没有字符串化
    let result = ExprSyntax("\(argument)")
    ```

<br/>

2. `"\(literal: ExpressibleByLiteralSyntax)"`: 在使用上可以直接提供String对象, 最终String被转换成语法树对象.
    ```swift
    // 提供信息为 "a + b"
    // 构造信息为 "a + b"
    //  注意有空格
    let result1 = ExprSyntax("\(literal: "a + b")")

    // 原始信息为 value = "a + b"
    // 构造信息为 "a + b"
    //  注意有空格
    let value = "a + b"
    let result2 = ExprSyntax("\(literal: value)")

    // 原始信息为 a + b
    // 构造信息为 "a+b"
    //  注意没有空格
    let result3 = ExprSyntax("\(literal: argument)")
    ```
    > 之所以能直接提供字符串, 是因为内部扩展的String遵循了该协议

<br/>

3. `"\(raw: T)"`: 可以指定任意类型的对象, 不会附加引号
    ```swift
    // 提供信息为 "a + b"
    // 构造信息为 a + b
    //  去掉了双引号, 相当于用户代码中有a和b两个对象在做加法操作
    let result1 = ExprSyntax("\(raw: "a + b")")

    // 原始信息为 value = "a + b"
    // 构造信息为 a + b
    //  也是去掉了双引号
    let value = "a + b"
    let result1 = ExprSyntax("\(raw: value)")

    // 原始信息为 a + b
    // 构造信息为 a + b
    //  去掉了双引号
    let result3 = ExprSyntax("\(literal: argument)")
    ```

<br/>

4. 构造过程中字面量的值会原样输出
    ```swift
    // 在字符串中有7个字面量
    //  左括号      {
    //  第1个双引号 "
    //  key         key
    //  第2个双引号 "
    //  冒号        :
    //  空格        空格
    //  右括号      }
    // 这些信息会原样输出
    // 插值部分是原样输出, 所以最终的结果:
    //  {"key": a + b}
    let result = ExprSyntax("{\"key\": \(raw: argument)}")
    ```

知道这些插值规则后回到上一小节所修改的函数

```swift
// 原表达式 #stringify(a + b)
// arg_0: 中缀表达式的左操作数信息
// op_id: 中缀表达式的操作符信息
// arg_1: 中缀表达式的右操作数信息

// __code_4
let result = ExprSyntax("(\(arg_0) \(op_id) \(arg_1), \"\(arg_0) \(op_id) \(arg_1)\")")

// __code_5
let result = ExprSyntax("(\(arg_0) \(op_id) \(arg_1), \(literal: arg_0.description)+\(literal: op_id.description)+\(literal: arg_1.description))")
```

对于`__code_4`:
1. tuple第1个参数`\(arg_0) \(op_id) \(arg_1)`中所有的插值对象是SwiftSyntax结点, 所以会直接生成不带双引号的`a + b`加法表达式
2. tuple第2个参数`\"\(arg_0) \(op_id) \(arg_1)\"`中所有的插值是SwiftSyntax结点, 所以会直接生成`a + b`, 但因为前后加了`"`, 所以组合起来就是`"a + b"`

<br/>

对于`__code_5`:
1. tuple的第1个参数直接原样输出`a + b`
2. tuple的第2个参数中插值对象是String,  但标注了`literal`, 则其实每个插值生成的是字符串化`"a" "+" "b"`, 但第2个参数同时还书写了`+`, 则直接生成的是值为`"a" + "+" + "b"`:
    - `#stringify(a + b)` 展开成了 `(a + b, "a" + "+" + "b")`
这个表达式也是符合stringify的声明


### 表达式上下文类型信息?
在给出的测试中stringify接收的是`a + b`表达式, 其中a在当前的上下文中是一个Int对象, 但这一点信息是无法在宏的实现中获取到. swift这样做的目的是限制表达式宏的处理范围, 也是一种安全处理机制.


<a id="link-liteal-expr"></a>

### 字符串变字面值?
通过`"\(raw: "let a = 20")"` 构造的表达式实际上展开后是`let a = 20`的swift声明语句并不是字符串, 现在假设有这样的调用:

```swift
#stringify("let a = 20") 
```
这种形式的展开是什么样呢? stringify的声明应该返回`(String, String)`, 那本来所传递的参数就是字符串, 根据stringify的实现

```swift
return "(\(argument), \(literal: argument.description))"
```

1. `\(argument)`所获取的是表达式的原始信息, 则对应的内容: `"let a = 20"`
2. `\(literal: argument.description)`所获取的是表达式的字面值, 所以要搞清楚这里的字面值的含义!! 

在swift中使用`#"hello \n world"#`扩展字符串分隔符来表示字符串的原始信息, 它被两个`#`包裹, 字符串不会发生转义. 在macro的处理中, 如果表达式本身是一个字符串, 则`"\(literal: value)"`将会转换成扩展字符串, 所以展开的结果:

```swift
("let a = 20", #"let a = 20"#) 
```

其实在stringify的实现中接收的值是<font color = red>带引号的字符串</font>, 即:
1. 外界传递的参数: `parm = "let a = 20"`
2. 内部接收时的值: `arg = "\"let a = 20\""`

举个案例: 去掉`"hello"`字符串中的引号, 在用户代码展开, 若上下文有hello对象, 则表达式就是正确的.

```swift
// 外界调用
#stringify("hello")

public struct StringifyMacro: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) -> ExprSyntax {
        guard let argument = node.arguments.first?.expression else {
            fatalError("compiler bug: the macro does not have any arguments")
        }
        // arg = "\"hello\""
        var arg = argument.description

        // 手动去掉引号, arg = "hello"
        arg.replace("\"", with: "")

        // 返回 (hello, "hello")
        //  但是上下文中没有hello, 所以是报错的
        return "(\(raw: arg), \(literal: arg))"
    }
}
```

### 宏的参数结点没有上下文
通过`#stringify(\"hello\")`传递一个字面量字符串, 在内部拿到的就是`"hello"`, 如果想先定义一个字符串, 然后传递进入宏, 则结果可能与想像的不一样:
```swift
let code = "hello"
#stringify(code)
```

在宏的内部拿到的结点只是`code`, 并不是code的值`"hello"`, 最终生成的是`(code, "code")`



### 插入动态信息
stringify的实现中直接通过`ExprSyntax`接收一字符串进行返回值的构造, 这个过程可以提供自定义的String对象, 只要该对象能保证最终生成的是正确的, 符合上下文的swift语句即可. 有了这个功能则可以在实现中动态插入自定义的信息.  这里笔者给出一个测试函数调用耗时的案例. 

```txt
功能需求
    在当前程中测试某段代码的执行时间

实现方式
    使用表达式宏添加表达式实现

调用格式
    #time_call  {
        print("hello")
    }

期望输出结果
    hello
    执行了xxx/秒

分析:
    1. time_call的书写格式决定了time_call的参数是一个尾随闭包
    2. 传递了 time_call闭包, 但用户没有产生调用, 所以
        应该在macro的实现内部自动调用
```

```swift
// 声明一个表达式宏time_call
//  接收一个闭包参数, 由于是唯一参数, 所以可以使用尾随闭包的语法
@freestanding(expression)   
public macro time_call(_ exec: () -> ()) -> Void = #externalMacro(module: "LBMacroMacros", type: "LB")


// 实现
public enum LB: DeclarationMacro, ExpressionMacro{
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax, 
        in context: some MacroExpansionContext) throws -> ExprSyntax {

/* __code_0 */       let tmp_arg_0 = context.makeUniqueName("")
/* __code_1 */       let tmp_arg_1 = context.makeUniqueName("")
/* __code_2 */       return
/* __code_3 */          """
/* __code_4 */          _ = {
/* __code_5 */              let \(raw: tmp_arg_0) = clock_gettime_nsec_np(os.CLOCK_REALTIME)
/* __code_6 */              _ = \(raw: node.trailingClosure?.description ?? "")()
/* __code_7 */              let \(raw: tmp_arg_1) = clock_gettime_nsec_np(os.CLOCK_REALTIME) - \(raw: tmp_arg_0)
/* __code_8 */              print("执行了\\(Double(\(tmp_arg_1)) * 1.0 / Double(os.NSEC_PER_SEC))/秒")
/* __code_9 */          }()
                        """
    }
}
```

1. macro声明要求没有返回值, 所以macro实现中`__code_4`是一个闭包调用, 没有返回

<br/>

2. `__code_0`: 生成唯一对象名, 表示开始的时间

<br/>

3. `__code_1`: 生成唯一对象名, 表示结束的时间

<br/>

4. `__code_2`: 返回字符串插值, 生成swift的表达式语句

<br/>

5. `__code_3`: 多行字符串前缀, 使用多行字符串来书写表达式时, 整个表达式比较直观

<br/>

6. `__code_4`: 整个macro要返回一个Void类型, 所以这里使用匿名闭包, 并自动调用(`__code_9`)

<br/>

7. `__code_5`: 表达式中第1句代码, 获取此刻程序运行的纳秒时间戳. 这里使用插值`\(raw: tmp_arg_0)`实际上将产生的对象名的字面值展开在用户代码中

<br/>

8. `__code_6`: 调用用户传入的闭包
    - 获取用户传入的闭包参数表达式的原始字面值信息(<font color = red>node.trailingClosure?.description</font>)
        ```swift
        {
            print("hello")
        }
        ```
        > 这些信息其实就是字符串

    - `_ = \(raw: node.trailingClosure?.description ?? "")()`  使其产生调用

<br/>

9. `__code_7`: 用户代码已经调用完毕, 获取此刻程序的运行时间并减去开始时间`__code_5`. 同样的是使用插值来生成表达式

<br/>

10 `__code_8`: 打印代码运行的时间. 同样也是使用插值来生成打印语句

<br/>

11. `__code_9`: 整个外层的闭包产生调用


代码最终展开类似如下:

```swift
_ = {
    // 这种长长的对象名由macro实现中的context生成, 保证了唯一性
    // 获取当前时间戳
    let $s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu_ = clock_gettime_nsec_np(os.CLOCK_REALTIME)

    // macro实现中的 `__code_6`, 调用用户的闭包
    _ = {
        print("hello")
    }()

    // 计算结束的时间戳
    let $s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu0_ = clock_gettime_nsec_np(os.CLOCK_REALTIME) - $s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu_

    // 打印总时间, 注意类型转换
    print("执行了\(Double($s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu0_) * 1.0 / Double(os.NSEC_PER_SEC))/秒")
}() 
```

需要注意的地方: 因为声明的是expression的独立宏, 所以不能有声明语句
```swift
public enum LB: DeclarationMacro, ExpressionMacro{
    public static func expansion(
    of node: some FreestandingMacroExpansionSyntax, 
    in context: some MacroExpansionContext) throws -> ExprSyntax {

    let tmp_arg_0 = context.makeUniqueName("")
    let tmp_arg_1 = context.makeUniqueName("")
    return
            """
            let \(raw: tmp_arg_0) = clock_gettime_nsec_np(os.CLOCK_REALTIME)
            _ = \(raw: node.trailingClosure?.description ?? "")()
            let \(raw: tmp_arg_1) = clock_gettime_nsec_np(os.CLOCK_REALTIME) - \(raw: tmp_arg_0)
            print("执行了\\(Double(\(tmp_arg_1)) * 1.0 / Double(os.NSEC_PER_SEC))/秒")
            """
    }
}

/************************* 展开后 **********************************/
let $s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu_ = clock_gettime_nsec_np(os.CLOCK_REALTIME)

_ = {
    print("hello")
}()

let $s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu0_ = clock_gettime_nsec_np(os.CLOCK_REALTIME) - $s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu_

print("执行了\(Double($s13LBMacroClient0015mainswift_tzEGbfMX36_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll9time_callfMf_7__localfMu0_) * 1.0 / Double(os.NSEC_PER_SEC))/秒")
```

展开到用户的代码后有声明的语句, 无法和macro声明时返回的Void类型对应, 所以直接报错. 也就是说当前macro的展开必须是一个Void类型的表达式. 该案例还有一点笔者没有处理
```swift
#time_call {
    print("hello")
}
```
在向宏传递参数时, 使用了尾随闭包的语法, 所以在协议函数中获取到的语法树结点的类型中参数列表中是空的, 但会多出一个`trailingClosure`的结点信息. 如果:

```swift
#time_call({print("hello")}) 
```
在形成的语法树结点的参数列表会出现ClosureExprSyntax. 



由于宏可以动态添加信息, 所以逻辑上可以作任何事情. 也就是说macro可能有改变用户代码的倾向, 但其实以独立表达式宏的使用来看, 它只是改变了表达式的意义, 它前后的上下文信息不会被改变!!! 但不管怎么样, macro有恶意的倾向, 事实上swift的宏实现还是有很多限制, 比如:
1. 不能异步调用
2. 不能产生网络访问
3. 不能访问源程序中的文件

后2条的原因是宏实现的库在被调用时的进程由swift决定, swift关闭了该进程的所有网络IO操作, 同时该进程处于封闭的沙盒工作空间, 它不能访问到源程序的工作空间. 当前的案例其实也是Swift6中的SwiftUI的`#Preview`的实现流程



### 表达式宏案例
笔者实现一个简单的数值字面量转换

```swift
// 宏声明 
//  这2个宏实际造成了重载, 必须接收数值字面量, 接收对象类型转换是失败的
@freestanding(expression)
public macro binary(_ value: Int) -> String = #externalMacro(module: "LBMacroMacros", type: "LB")
@freestanding(expression)
public macro binary(_ value: Double) -> String = #externalMacro(module: "LBMacroMacros", type: "LB")


// 宏实现
public enum LB: ExpressionMacro{
    static let FLOAT_MASK:Set<String> = [".", "e", "E", "p", "P"]
    static let NOT_DECIMAL: Dictionary<String, Int> = [
        "0b": 2, "0B":2, "-0b":2, "-0B":2,
        "0o": 8, "0O":8, "-0o":8, "-0O":8,
        "0x": 16, "0X":16, "-0x":16, "-0X":16
    ]
    static let DECIMAL_BASE = 10

    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext) throws -> ExprSyntax {

            guard let arg = node.arguments.first else {
                fatalError("请传递参数")
            }

            var ex = arg.description

            // 浮点
            if !(FLOAT_MASK.filter {ex.contains($0)}).isEmpty {
                if let number = Double(ex) {
                    return "\(literal: String(number.bitPattern, radix:2))"
                }
            }

            // 整数, 因为这里接收的所有信息都是字符串, 所以需要转换

            // 取出表达式的进制
            let radix = NOT_DECIMAL.filter {ex.hasPrefix($0.key)}.first?.value ?? DECIMAL_BASE

            // 是否为负数
            let negative = ex.hasPrefix("-")

            // 去掉前缀(0b, -0b, 0x, -0x等)
            negative ? ex.replaceSubrange(ex.startIndex..<ex.index(ex.startIndex, offsetBy: 1), with: "") : ()
            radix == DECIMAL_BASE ? () :  ex.replaceSubrange(ex.startIndex..<ex.index(ex.startIndex, offsetBy: 2), with: "")

            // 从字符串转换成UInt, 注意转换的步骤
            let decimal = UInt(bitPattern: (Int(ex, radix: radix)! * (negative ? -1 : 1)))

            return "\(literal: String(decimal, radix:2))"

            // 关于错误的正确做法将在后续给出, 这里先不管
            throw "参数必须是数字字面量"
    }
}



// 使用
let number = 2

print(#binary(10))
print(#binary(-10))
print(#binary(0b10))
print(#binary(-0b10))
print(#binary(0o10))
print(#binary(-0o10))
print(#binary(0x10))
print(#binary(-0x10))
print(#binary(0.5))
print(#binary(-0.5))
print(#binary(5e-1))
print(#binary(-5e-1))
print(#binary(number))      // error, 内部解析出错, 不是一个字面量数值

#if false
1010
1111111111111111111111111111111111111111111111111111111111110110
10
1111111111111111111111111111111111111111111111111111111111111110
1000
1111111111111111111111111111111111111111111111111111111111111000
10000
1111111111111111111111111111111111111111111111111111111111110000
11111111100000000000000000000000000000000000000000000000000000
1011111111100000000000000000000000000000000000000000000000000000
11111111100000000000000000000000000000000000000000000000000000
1011111111100000000000000000000000000000000000000000000000000000
#endif
```


### 独立宏(声明)
前面学习的stringify宏就是独立宏, 只不过是其中的一种, 独立宏有2种:
1. 表达式
2. 声明

表达式角色的独立宏正如stringify, 使用`@freestanding(expression)`指定, 它们只能出现在表达式的地点, 也只能返回swift的表达式. 而声明的独立宏:
1. 只能出现声明位置
2. 展开后是一段声明

声明的含义:
1. 声明对象
2. 声明函数
3. 声明闭包
4. 声明类型
    - enum
    - struct
    - class

这里再提一点, 表达式和声明在swift中是有严格区分的, 表达式一定有一个结果反馈, 换言之对应一个结果类型. 声明严格来说是swift语句, 但它不是表达式, 而像stringify实现中返回ExprSyntax时可以指定一条声明语句, 但最终回到用户代码是编译报错的, 因为展开后的声明语句和stringify的声明时返回类型对不上

```swift
// 将stringify的实现修改如下(部分) 
public struct StringifyMacro: ExpressionMacro {
    public static func expansion(
        of node: some FreestandingMacroExpansionSyntax,
        in context: some MacroExpansionContext
    ) -> ExprSyntax {
        return ("let d: Int = 0")
    }
}
```
这里其实向外界返回了一条这样的swift语句:

> `let d: Int = 0`

它是正确的swift语句, 但最后在用户代码展开时直接报错, 因为stringify的声明保证会返回一个tuple, 但该展开的swift语句并不是一个tuple类型的结果, 所以报错. 可以使用`@freestanding(declaration)`的宏展开一段声明:
1. 声明对象
2. 声明类型(enum, struct, class等)
3. 声明函数

> 由于它也是独立宏, 所以不需要依赖上下文中的信息. 即写出来就直接展开声明. 

### swift与插件的交互探究
macro的实现本质上是一个独立的进程, 它接收swift生成语法树结点信息并被封闭调用, 然后处理这些信息再生成新的语法树结点信息再回传给swift. 在整个过程中并不能确定2者交互的载体是不是字符串, 即可能是:
1. swift先生成语法树结点的片段信息, 整合成字符串
2. 创建交互的通道
    - 可能是共享内存
    - 也可能是UDS(<font color = red>Unix Domain Socket</font>)
    - 也可能是管道, 文件等
3. fork子进程, swift阻塞等待子进程
4. 子进程关闭可能IO的所有文件描述符
5. 子进程和父进程交互, 子进程从通道中获取结点信息的字符串, 生成可操作的结点的内存结构
6. 子进程重新生成新的结构(<font color = red>回调函数</font>), 再转换成字符串信息通过通道发给父进程(swift)
7. swift收到新的结点信息(字符串)后, 将结点信息转换成表达式, 并展开在调用点

这个只是笔者理解的大致过程. 可以写一个程序来测试:
1. 创建一个独立的声明宏
2. 在实现函数中遍历所有的fd, 然后找到打开的那个查看其文件类型

```swift
// 声明
//  这里加了一个属性, 指定生成的对象名是abc这个标识
//  关于声明时对象的标识会在下小节详细探究
@freestanding(declaration, names: named(abc))
public macro decl_var() = #externalMacro(module: "LBMacroMacros", type: "LB")


// 辅助工具
private enum FILE_TYPE: Int, RawRepresentable, CaseIterable{
    // __code_sys_ftype_mask
    static let MASK =  0o170000

    // __code_sys_ftype_no
    case S_ISFIFO = 0o0010000
    case S_ISCHR = 0o0020000
    case S_ISDIR = 0o0040000
    case S_ISBLK = 0o0060000
    case S_ISREG = 0o1000000        // 4528
    case S_ISLNK = 0o1200000
    case S_ISSOCK = 0o1400000
    case S_NOFILE = -1

    typealias RawValue = String

    // 这个就是测试用的
    init?(rawValue: String) {
        self = .S_NOFILE
    }
    init(_ rawValue: Int) {
        switch rawValue {
            case 0o0010000:
                self = .S_ISFIFO

            case 0o0020000:
                self = .S_ISCHR

            case 0o0040000:
                self = .S_ISDIR

            case 0o0060000:
                self = .S_ISBLK

            case 0o1000000:
                self = .S_ISREG

            case 0o1200000:
                self = .S_ISLNK

            case 0o1400000:
                self = .S_ISSOCK

            default:
                self = .S_NOFILE
        }
    }

    var rawValue: String {
        switch self {
            case .S_ISFIFO:
                return "管道"

            case .S_ISCHR:
                return "字符设备"

            case .S_ISDIR:
                return "目录"

            case .S_ISBLK:
                return "块设备"

            case .S_ISREG:
                return "文件"

            case .S_ISLNK:
                return "软链接"

            case .S_ISSOCK:
                return "socket"

            case .S_NOFILE:
                fallthrough
            @unknown default:
                return "不合法的文件"
        }
    }
}

// 独立声明宏的实现类, 这里笔者定义了一个空枚举, 就是一个方法的容器
public enum LB: DeclarationMacro, ExpressionMacro{
    public static func expansion(
        of node: some SwiftSyntax.FreestandingMacroExpansionSyntax,
        in context: some SwiftSyntaxMacros.MacroExpansionContext) 
    throws -> [SwiftSyntax.DeclSyntax] {

        // 从后往前遍历, 因为笔者不确定前3个fd是否真的未关闭.
        for i in ((0..<1024) as Range<Int32>).reversed() {
            var s: os.stat = .init()
            // 若失败, 则表示当该描述符没有打开, 继续下一个
            if os.fstat(Int32(i), &s) < 0 {
                continue
            }

            // 比对
            let find = FILE_TYPE.allCases.filter {
                $0 == .init(Int(s.st_mode) & FILE_TYPE.MASK)
            }

            // 比对成功, 输出格式, eg: let abc = "文件类型是:管道<fd:15, mode:4528>"
            return ["let abc = \"文件类型是:\(raw: find.first!.rawValue)<fd:\(raw: i), mode:\(raw: s.st_mode)>\""]




            #if false
            // 这里是测试向这个fd中写入一个字符串化的语法结点表达式
            //  实际测试出来的文件描述符是管道,
            // 笔者的目的是测试一下, 向这个管道写入一个结点树信息看有什么效果
            //  但最后在用户端没有任何效果, 说明swift和插件之间的通信并不是想像的那么简单
            //  PS: 调用debugDescription显示的信息是树状的描述

            // 修改管道文件为非阻塞模式, 这样可以向管道写入内容, 而不在乎是否有读者
            let o = os.fcntl(i, os.F_GETFL)

            // 修改失败后, 直接返回错误的原因
            if os.fcntl(i, F_SETFL, o | os.O_NONBLOCK) < 0 {
                return ["let abc = \(literal: String(cString: os.strerror(os.errno)!))"]
            }

            let return_value = [ DeclSyntax("let abc = \"hello\"")]
            let str = return_value.debugDescription
            write(i, str, str.count)

            #endif
        }

        // 这是一个埋点
        return ["let abc = {0x100}()"]
    }
}
```

测试流程:
1. 在回调函数中直接从后往前遍历所有的fd. 经过笔者的测试, 当前插件的进程中会开15个管道, 如果插件和swift是以管道进行通信的, 则里面应该有一个管道是交互语法树结点的信息, 这个笔者没有测试出来

<br/>

2. 遍历到当前的fd后调用`fstat`函数, 获取文件的`s.st_mode`值, 该值中记录了文件类型的信息.
    > 笔者先定义系统文件(MacOS平台)的编号, 这个编号是从系统头文件`sys/stat.h`中直接拿过来的. 因为系统C层面提供的接口是宏调用, 而在swift中是无法引用系统宏相关的调用代码, 所以笔者将判断文件类型的宏做了展开:
    ```swift
    var s = os.stat.init()
    file_type = os.fstat(fd, &s)
    
    file_no = s.st_mode & 0o170000
    // 注意是八进制
    ```

3. 经过测试打印有15个fd都是是管道文件, 也就是说是和其他进程进行通信用的. 但通信的细节, 这里笔者没有能力去过分深究



### 声明宏的场景
笔者前面提过到, 声明这种动作可以发生在不同场景下:
1. 声明对象
2. 声明函数
3. 声明lambda
4. 声明类型(enum, struct, class等)


### 声明时named属性值
回过去看`decl_var`的声明:
```swift
@freestanding(declaration, names: named(abc))
public macro decl_var() = #externalMacro(module: "LBMacroMacros", type: "LB")
```

[前面](#link-liteal-expr)曾经测试过, macro可以将用户传递的字符串进行字面化,  如`"let age = 8"`生成`let age = 8`的表达式, 但展开合不合乎上下文由swift决定. 直白点如果用户提供一个`"name"`给宏的参数, 理论上宏可以生成name对象, 至于展开到用户代码后能不能通过是有限制的:
1. 上下文不能有name对象
2. 宏声明时是要注册`name`这个标识符, 通过

```swift
@freestanding(declaration, names: named(abc), named(ABC), named(name))
```
向外界表示内部生成的标识符名称为`abc`, `ABC`, `name`, 但其实到底有没有生成取决于:
1. 用户调用宏
2. 该宏确实在内部声明了这3个标识符

当声明宏声明了这些标识符, 并同时在内部声明了对应的对象时, 即使宏被用户调用, 也存在很多限制(<font color = red>笔者自己测试出来的</font>), 以name来说: 
1. name标识符的作用域只存在全局

<br/>

2. 当未在任何全局区调用宏, 则意味着没有生成name.
    - 若此刻在局部区调用宏不访问name时, 则编译<font color = red>直接报错</font>, name未定义
    - 若此刻在局部区调用宏且访问name时, 则编译<font color = red>直接报错</font>, name未定义

<br/>

3. 当在全局区调用宏(<font color = red>只允许调用一次</font>), 就生成民name
    - 若此刻在局部区调用宏不访问name时, 则编译<font color = red>不会报错</font>, 
    - 若此刻在局部区调用宏且访问name时, 则编译<font color = red>不会报错</font>, 访问的name是全局的

在局部区调用宏从生成的汇编来看, 其实是直接在给局部对象赋值, 逻辑来看是作废的(<font color = red>没用的代码</font>)
    
```swift
// 声明
@freestanding(declaration, names: named(abc))
public macro decl_var() = #externalMacro(module: "LBMacroMacros", type: "LB")

// 实现, 为了方便, 笔者这里只给出返回的表达式代码
return ["let abc = n"]


// 调用场景:上下文
let n = 0xa
#decl_var       // 展开后: let abc = n
print(abc)      // 10
```

程序中在全局区调用了宏, 宏展开后相当于在原地定义了abc, 并且它的值是n. 如果在局部作用域中<font color = red>单独</font>调用宏: error(找不到abc这个标识符)

```swift
let n = 0xa

do {
    #decl_var       // error: 找不到abc对象
}

func test() {
    #decl_var       // 同上, 找不到abc对象
    print(abc)      
}
```

如果先在全局区调用宏, 则其他任何局部区域的调用, 相当于什么都没有写

```swift
let n = 0xa         

#decl_var               // 在全局区调用1次, 生成了全局对象abc, 值为n

func test() {
    #decl_var           // 相当于什么都没写
    #decl_var           // 同上

    let number = abc + 0xa    
                        // 访问的是全局对象abc
}

// #decl_var           // error: 重复定义abc
```

这个行为很让人迷惑, 因为笔者已经给了结论: <font color = red>局部域中调用宏相当于都没写</font>, 这个结论是笔者从行为的效果上总结的, 接下来看汇编实现:

```lua
LBMacroClient`test():
    0x10000216c <+0>:  sub    sp, sp, #0x30
    0x100002170 <+4>:  stp    x29, x30, [sp, #0x20]
    0x100002174 <+8>:  add    x29, sp, #0x20
    0x100002178 <+12>: stur   xzr, [x29, #-0x8]     ; *(x29 - 8) = 0, tmp_local_0 = 0
    0x10000217c <+16>: str    xzr, [sp, #0x10]      ; *(sp + 16) = 0, tmp_local_1 = 0
    0x100002180 <+20>: str    xzr, [sp, #0x8]       ; *(sp + 8) =  0, tmp_local_2 = 0

    0x100002184 <+24>: adrp   x8, 6                 
    0x100002188 <+28>: ldr    x9, [x8, #0x360]
    0x10000218c <+32>: stur   x9, [x29, #-0x8]
    0x100002190 <+36>: ldr    x8, [x8, #0x360]
    0x100002194 <+40>: str    x8, [sp, #0x10]       ; 笔者没有给出main函数的汇编, 这里实际是:
                                                    ;   x9 = *&n, 即将n的值存储到局部对象中, x9就是局部对象
                                                    ;   tmp_local_0 = n
                                                    ;   tmp_local_1 = n
                                                    ;   这2条语句相当于, #decl_var的展开
                                                    ; 所以笔者才说局部对象中对声明宏的调用相当于没写.
                                                    ;   可以预想到在release下, 这些没有的代码将会被优化掉


->  0x100002198 <+44>: bl     0x1000021e0           
; LBMacroClient.abc.unsafeMutableAddressor : Swift.Int at 
;   @__swiftmacro_13LBMacroClient0015mainswift_tzEGbfMX8_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll8decl_varfMf_.swift:1
                                                    ; 该函数是 dispatch_once, 获取全局对象abc的地址

    0x10000219c <+48>: ldr    x8, [x0]              ; x8 = *&abc, 实际abc内存中的值在进入函数前是n的值
    0x1000021a0 <+52>: adds   x8, x8, #0xa          ; x8 = x8 + 10 ==> abc += 0xa
    0x1000021a4 <+56>: str    x8, [sp]              ; *sp = x8
    0x1000021a8 <+60>: cset   w8, vs                ; 检查是否溢出
    0x1000021ac <+64>: tbnz   w8, #0x0, 0x1000021c8 ; <+92> [inlined] Swift runtime failure: arithmetic overflow at <compiler-generated>
                                                    ;   如果 w8<0bit> == 1, 则表示溢出, 即 +52 加法操作如果溢出会导致
                                                    ;   状态寄存器的v标志位置位, 这里其实就是在检查这个位

    0x1000021b0 <+68>: b      0x1000021b4           ; <+72> at main.swift, 未溢出 
    0x1000021b4 <+72>: ldr    x8, [sp]              ; x8 = *sp, 即加法的结果
    0x1000021b8 <+76>: str    x8, [sp, #0x8]        ; tmp_local_2 = x8
    0x1000021bc <+80>: ldp    x29, x30, [sp, #0x20] ; 还原栈底指针x29, 还原函数要返回的地址到x30中
    0x1000021c0 <+84>: add    sp, sp, #0x30         ; 销毁栈桢
    0x1000021c4 <+88>: ret                          ; 通过x30返回
    0x1000021c8 <+92>: brk    #0x1                  ; 溢出异常
```

从汇编中可以看出: 局部区对宏的调用实际什么也没有做!! 根据这种情况, 如果有2个宏的声明和实现是一样的, 只是宏名不同, 则第2个用到的宏其实就是第1个

```swift
// 宏的声明
@freestanding(declaration, names: named(abc), named(ABC), named(name))
public macro decl_var(_ value: String = "") = #externalMacro(module: "LBMacroMacros", type: "LB")

@freestanding(declaration, names: named(abc), named(ABC), named(name))
public macro decl_var2(_ value: String = "") = #externalMacro(module: "LBMacroMacros", type: "LB")


// 宏的实现, 两者是一样的
return ["let abc = n"]


let n: Int = 0xa

#decl_var


func test() {
    #decl_var2  // 因为它的实现和decl_var一样, 所以这里相当
                // #decl_var, 并且这里的调用相当于撒也没写
    #decl_var
    var number = abc + 0xa
}
test() 
```

从汇编中了解到局部区调用宏时, 是通过固定的函数获取对应的全局对象的地址, 如果是在全局区调用宏呢? 根据以前的学习:
1. 全局对象(<font color = red>非static</font>)的访问都是直接寻址. 
2. 全局对象的初始化正常使用时都是线程安全的(<font color = red>在POSIX线程中骚操作除外</font>)

而声明宏的本质上是在声明一个全局对象, 理论上来看它的访问也是直接寻址的. 这些具体的细节将在后续详细探究. 借助于named属性, 用户确实可以在外界给出一个表达式的字符串, 由内部生成, 只不过涉及到对象时, 必须由宏先声明好



### 生成唯一标识
声明宏在实现函数中指定声明表达式时, 表达式中的对象名必须与该宏声明标识符一致(named属性值), 这是声明宏的默认规定. 实际业务中, 声明宏可以生成内部的对象名, 这种对象名不需要指定named, 外界引用不到. 

```swift
@freestanding(declaration, names: named(abc), named(ABC), named(name))
public macro decl_var(_ value: String = "") = #externalMacro(module: "LBMacroMacros", type: "LB")

// 实现
public static func expansion(
    of node: some SwiftSyntax.FreestandingMacroExpansionSyntax,
    in context: some SwiftSyntaxMacros.MacroExpansionContext) throws -> [SwiftSyntax.DeclSyntax] {
        return ["let abc = n; let \(raw: context.makeUniqueName("")) = n"]
}


// 调用
let n = 50
#decl_var   

// 相当于生成了
let n = 50
let abc = n     // 由named指定, 编译不会报错
let $s13LBMacroClient0015mainswift_tzEGbfMX10_0_33_27A6C6D516578B6CA358B1D61B5D3419Ll8decl_varfMf_7__localfMu_ = n
```

这个很长的标识符由插件生成, 它能保证该标识符不会和工程中的其他标识符重名,所以在宏的声明语句中不用特意指出来, 同时在用户代码中也无权访问, 因为这是系统标识符(<font color = red>以$开头</font>).


### let对象声明和初始化
当在实现声明一个let对象时, 有没有初始化或初始化方式都会导致程序有不同的行为

```swift
@freestanding(declaration, names: named(abc))
public macro decl_var(_ value: Int = 0) = #externalMacro(module: "LBMacroMacros", type: "LB")

public static func expansion(
    of node: some SwiftSyntax.FreestandingMacroExpansionSyntax,
    in context: some SwiftSyntaxMacros.MacroExpansionContext) throws -> [SwiftSyntax.DeclSyntax] {
        // 返回表达式
}
```

当声明时不初始化
```swift
return ["let abc: Int"] 


// 调用
#decl_var(0)        // 可以省略参数, 因为宏的参数有默认值

// 展开后
let abc: Int
abc = 2             // 自己初始化, 没有问题
```

当声明时直接初始化
```swift
return ["let abc = 2"]

// 调用
let n = 0xa
#decl_var(0)        // 0传递了相当于没用上

// 展开后
let abc = 2         // 编译期不会报错
```
程序运行后将直接崩溃, 原因是: `let abc = 2`中的abc其实位于程序的常量区[^ann-mem-const], 常量区数据是禁止修改的. 看一下生成的汇编:

```lua
LBMacroClient`main:
->  0x100002204 <+0>:  adrp   x9, 6                     ; __addr_global, 全局区
    0x100002208 <+4>:  mov    w8, #0xa                  ; =10 
    0x10000220c <+8>:  str    x8, [x9, #0x360]          ; a = 0xa = 10

    0x100002210 <+12>: adrp   x9, 1                     ; 这里发现 x9 地址并不是 __addr_global
                                                        ;   实际这个地址是常量区, x9 = 0x100002210 & (~0xfff) + (1 << 12) = 0x100003000
                                                        ;   这个地址紧挨着代码区, 在内存里是常量区, 当然
                                                        ;   要验证它是常量区, 应该看mach-o文件, 笔者这里不演示了
    0x100002214 <+16>: mov    w8, #0x2                  ; =2 
    0x100002218 <+20>: str    x8, [x9, #0xa78]          ; *&abc = 2, 向常量区(0x100003a78)写入数据将直接崩溃

    0x10000221c <+24>: mov    w0, #0x0                  ; =0 
    0x100002220 <+28>: ret     
```

事实上abc对象的空间在编译时就已经存储好了初始化的值2

```lua
(lldb) x/gx 0x100003a78        ; abc空间里的值已经在编译时就指定好了
0x100003a78: 0x0000000000000002
```

上述测试中声明abc对象时赋一个Int导致程序崩溃, 笔者认为有必要测试通过传入的参数初始化看有没有问题:

```swift
public static func expansion(
    of node: some SwiftSyntax.FreestandingMacroExpansionSyntax,
    in context: some SwiftSyntaxMacros.MacroExpansionContext) throws -> [SwiftSyntax.DeclSyntax] {
        // 接收的参数是Int类型, 这里必须取出参数的原始信息
        //  使用raw表示取出的就是Int
        //  如果使用literal则会将Int转换为字符串
        return ["let abc = \(raw: node.arguments.first!)"]
} 


// 调用
#decl_var(2)

// 展开
let abc = 2         // 这个2在内部是通过解析语法树中的结点取出来的
```

经过测试程序同样崩溃, 原因和前面一样: 不能向常量区写入数据. 正确的赋值(Int)方式:
1. 使用闭包
2. 调用Int相关的某些初始化方法
    - `Int.init(number)`
    - `Int(number)`
3. 赋值一个已知的全局对象(<font color = red>笔者不推荐</font>)

```swift
// 使用闭包
return ["let abc = {2}()"]  

// 调用
#decl_var(0)    // 0相当于没有用上
// 展开
let abc = {2}() // 在程序运行中不会有问题



// 使用初始化方法
return ["let abc = Int.init(2)"]

// 调用
#decl_var(0)
// 展开
let abc = Int.init(2)       // 程序运行也没有问题




// 使用已知的值初始化
//  必须有一个n的全局对象
return ["let abc = n"]

// 调用(有上下文)
let abc = 0xa
#decl_var(0)            // 没有问题
```

> 这些情况下abc实际位于全局区, 所以可以向它的内存写入数据.  

abc位于常量区的情况只发生于声明let对象时, 并且:
1. 初始化为Int字面值
2. 初始化为Double字面值
3. 初始化为nil字面

也就是说, 如果声明的let对象初始化值是:
1. 字符串
2. 数组
3. 字典
4. enum
5. struct
6. class

这些情况下程序是正常的



### var对象的声明和初始化
声明一个var对象和let有差异:
1. 必须是并发安全的, 一般使用`@MainActor`修饰
2. 因为第1条该宏不可以在局部区调用
    - `@MainActor`不能修饰局部对象 
3. var对象不可能在常量区, 所以初始化值可以随意指定

> 笔者这里就不详细举例了



### 附加宏
附加宏不同于声明宏, 笔者从它们所在的功能上来讨论, 这些宏依赖已经存在的swift元素:
1. 对象
2. 函数
3. 类型

它们主要的功能是为修饰的元素附加新的属性. 如:
1. 对象附加didset和willset
2. 函数添加一个重载
3. 对类型做附加操作

事实上它们也能做如声明宏相关的操作, 因为做不做做附加这个行为是实现者决定, 在实现里可以做附加操作, 也可以声明新的对象(<font color = red>如同`decl_var`一样</font>). 

它们的工作流程:
1. swift遇到附加宏, 创建这些宏所修饰对象的Syntax结构(<font color = red>笔者认为是纯字符串</font>)
2. 根据附加宏的声明, swift能确定要调用哪个模块的哪个实现函数
3. fork出子进程, 调用模块函数. swift自身会阻塞等待模块函数执行完毕
4. 模块函数处于新的进程中, 接收swift传递过来的结点信息
5. 在实现函数内部解析这些结点信息, 做一些自定义的附加操作
6. 将生成好的新结点回传给swift
7. swift收到新结点(<font color = red>字符串</font>)后, 再生成对应的Syntax插入到调用点之后

> 第7步的过程swift并不会删除或修改原来的结点, 只是在结点后再插入新的结点. 这也就是macro只能做扩展, 而无法修改或删除原始结点的原因. 

这个过程是笔者从逻辑上理解的, 因为笔者认为插件进程和swift进程之间的信息载体应该是字符串(<font color = red>就像调试中lldb打印的结点结构一样</font>). 

实现一个附加宏的过程(<font color = red>以peer来举例</font>):
```swift
// 声明部分:
//     1. 使用 @attached声明
//     2. 指定宏的角色peer
//     3. 指定模块(LBMacroMacros)和实现者(Peer)
@attached(peer, names: overloaded, named(a))
public macro add() = #externalMacro(module: "LBMacroMacros", type: "Peer")

// 由于宏的角色是 peer, 所以实现者(Peer)应该遵循相应的协议, 然后实现对应的协议方法
public enum Peer: PeerMacro{        // 遵循对应的宏实现协议
    // 实现对应的协议方法
    public static func expansion<
        Context: MacroExpansionContext,
        Declaration: DeclSyntaxProtocol
    >(
        of node: AttributeSyntax,
        providingPeersOf declaration: Declaration,
        in context: Context
    ) throws -> [DeclSyntax] {
        return ["let a = print(\"hello\")"]
    }
}

// 使用
@add
let number = 20

// 展开
let number = 20
let a = "hello"
```

这个小案例确实做了附加操作, 但并不是做了重载(<font color = red>声明时属性值有overloaded</font>)行为, 它只是单纯的添加了一个新的对象. 

> 笔者其实想要表达: 对等(peer)只是一个概念, 要不要实现重载操作由实现者决定


附加宏存在的意义是为其修饰的元素添加新的属性, 但不同的元素所能添加的属性是不一样的, 如对象可以添加监听, 类型可以添加成员, 函数可以重载等. 为了区分这些元素的添加行为, 附加宏有5种类型:

|attach|功能|
|:-|:-|
|peer|添加新的声明|
|accessor|向属性添加getter, setter|
|memberAttribute|为类型, 扩展添加属性|
|member|为类型添加成员|
|conformance|为类型添加协议|
|extension|扩展类型|

这5种类型在实现是要遵循不同的宏协议, 然后在对应的回调方法中解析swift给出的结点信息. 所以笔者先不讨论这些宏具体的用途, 先来探究怎么解析:
1. 函数
2. 类型

函数声明部分在编译器看来是一个完整的函数签名, 笔者没有能力去深究这些编译器层面的知识, 这里只关心签名中的:
1. 函数名
2. 函数参数
3. 函数返回值
4. 闭包参数(<font color = red>可能作为参数, 也可以是尾随闭包</font>)
5. 函数属性

类型也是一样的道理, 先来看函数. 笔者以peer宏的回调函数来举一些函数范例, 该宏的代码如下:

```swift
@attached(peer, names: overloaded,named(Msg))
public macro add() = #externalMacro(module: "LBMacroMacros", type: "Doth") 

public enum Doth: PeerMacro{
    public static func expansion(
        of node: SwiftSyntax.AttributeSyntax,
        providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
        in context: some SwiftSyntaxMacros.MacroExpansionContext)
    throws -> [SwiftSyntax.DeclSyntax] {
        return []
    }
}
```
该宏什么也不返回, 即不会向原始的元素添加任何信息. 在回调函数中打上断点, 然后通过lldb查看declaration的结构(<font color = red>po declaration</font>).


### 函数1
先测试一个最普通的函数: <font color = red>无参数, 无返回, 无实现</font>
```swift
@add                // 没有参数可以省略括号
func DO(){} 
```

通过断点打印出声明信息:

```swift
FunctionDeclSyntax                                  // __syntax_decl_func
├─attributes: AttributeListSyntax                   // __syntax_att_list
│ ╰─[0]: AttributeSyntax                            // __syntax_att
│   ├─atSign: atSign                                // __syntax_att_at
│   ╰─attributeName: IdentifierTypeSyntax           // __syntax_att_type
│     ╰─name: identifier("add")                     // __syntax_att_name
├─modifiers: DeclModifierListSyntax                 // __syntax_modi
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)    // __syntax_func_key
├─name: identifier("DO")                            // __syntax_func_name
├─signature: FunctionSignatureSyntax                // __syntax_func_sign
│ ╰─parameterClause: FunctionParameterClauseSyntax  // __syntax_func_parm
│   ├─leftParen: leftParen                          // __syntax_parm_(
│   ├─parameters: FunctionParameterListSyntax       // __syntax_parms_list
│   ╰─rightParen: rightParen                        // __syntax_parms_)
╰─body: CodeBlockSyntax                             // __syntax_func_impl
  ├─leftBrace: leftBrace                            // __syntax_func_impl_{
  ├─statements: CodeBlockItemListSyntax             // __syntax_func_impl_content
  ╰─rightBrace: rightBrace                          // __syntax_func_impl_}
```

这个结点完整的描述了`DO`函数的所有信息:
1. `__syntax_decl_func`: DO整体上是一个函数

<br/>

2. `__syntax_att_list`: DO函数所具有的属性, swift函数属性一般是告诉编译器的动作, 像:
    - `@propertyWrapper`
    - `@available`
    - 这里的宏(`@add`)

<br/>

3. `__syntax_att`: DO函数的某个属性, 它本身又是树状结构. 这里DO有一个add属性

<br/>

4. `__syntax_att_at`: 即`@add`中的`@`

</br>

5. `__syntax_att_type`: add属性名信息, 它是一个标识符

</br>

6. `__syntax_att_name`: add属性名

<br/>

7. `__syntax_modi`: 这里先不关心这种信息

<br/>

8. `__syntax_func_key`: swift中的函数关键字`func`

<br/>

9. `__syntax_func_name`: 函数名`DO`

<br/>

10. `__syntax_func_sign`: 函数签名部分, 它又是一个新的结点 

</br>

11. `__syntax_func_parm`: 函数签名中参数部分, 是一个结点

<br/>

12. `__syntax_func_parm_(`: 参数部分开始的括号

<br/>

13. `__syntax_func_parms_list`: 参数列表, 它是一个数组, 因为现在没有参数, 所以数组是空

<br/>

14. `__syntax_func_parm_)`: 参数结束的括号

<br/>

15. `__syntax_func_impl`: 函数体部分, 它是一个结点

<br/>

16. `__syntax_func_impl_{`: 函数实现开始的括号

<br/>

17. `__syntax_func_impl_content`: 函数实现体, 因为DO函数的实现是空的, 所以该结点也是空的. 如果函数内有语句, 则该结点的层次结构会继续往下, 函数中的每1条语句都会像当前的函数声明一样再次用对应的结点树表示. 
    > 一个swift源文件的语法树是极其复杂的, 源码中的任何一个元素都可以在语法中找到

<br/>

18. `__syntax_func_impl_}`: 函数体结束的括号


解析语法树的过程必须对整个SwiftSyntax非常熟练, 目前给出的函数是最简单的. 如果涉及到函数的参数, 标签, 默认参数, 闭包, 异常, 参数属性(<font color = red>如@escaping, inout</font>)等, 结点将会变得非常复杂. 先来做一些简单的解析:
1. 获取函数名
2. 获取函数参数
3. 获取函数返回值
4. 整个函数体


```swift
public enum Doth: PeerMacro{
    public static func expansion(
        of node: SwiftSyntax.AttributeSyntax,
        providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
        in context: some SwiftSyntaxMacros.MacroExpansionContext)
    throws -> [SwiftSyntax.DeclSyntax] {
        // 判断声明的类型
        guard let function = declaration.as(FunctionDeclSyntax.self) else {
            return ["let Msg = \"不是函数类型\""]
        }


        // 函数名
        let func_name = function.name.text;
        print(func_name)        // DO

        let args = function.signature.parameterClause.parameters
        print(args)             // 空

        let ret = function.signature.returnClause?.type
        print(ret ?? "Void")    // Void
                                //  DO函数在书写时, 没有指定任何返回值,
                                //  这在逻辑上表示返回Void, 但此刻生成的语法树不会
                                //  有函数的返回信息, 除非用户特意书写:
                                //  DO() -> (){} 或 DO() -> Void{}
                                //  这个时候语法树上才有这些信息

        let impl = function.body
        print(impl ?? "no body")    // {}
                                    // 函数的实现体什么内容都没有
        return []
    }
} 
```


### 判断函数是否无返回
函数返回Void的情况有:
1. 函数在书写时没有指定返回
2. 函数在书写时指定返回为`()`
3. 函数在书写时指定返回为`Void`

```swift
@add
func DO() -> Void{}

@add
func DO() -> () {}

@add
func DO(){}

@add
func DO() /*这是注释: 返回值是空的*/ {} 

@add
func DO() -> /*这是注释: 有返回值*/ (){} 



// 当是 -> Void 时, 对应的结构
IdentifierTypeSyntax
╰─name: identifier("Void")

// 当是 -> () 时, 对应的结构
ReturnClauseSyntax
├─arrow: arrow
╰─type: TupleTypeSyntax
  ├─leftParen: leftParen
  ├─elements: TupleTypeElementListSyntax
  ╰─rightParen: rightParen

// 当是 func DO() {}时
//  没有 returnClause结点

// 当是func DO() /*这是注释: 返回值是空的*/ {} 
//  也没有 returnClause结点

// 当是func DO() -> /*这是注释: 有返回值*/ (){} 
ReturnClauseSyntax
├─arrow: arrow
╰─type: TupleTypeSyntax
  ├─leftParen: leftParen
  ├─elements: TupleTypeElementListSyntax
  ╰─rightParen: rightParen

public static func expansion(
        of node: SwiftSyntax.AttributeSyntax,
        providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
        in context: some SwiftSyntaxMacros.MacroExpansionContext)
    throws -> [SwiftSyntax.DeclSyntax] {
    var is_void: Bool = false

    // 返回值部分是空的 func DO() {} 或 func DO() /*这是注释: 返回值是空的*/ {}
    guard let ret = function.signature.returnClause else{
        is_void = true
        return []
    }

    
    // 返回值有内容
    //  并且是: -> Void
    if ret.type.as(IdentifierTypeSyntax.self)?.name.text == "Void" {
        is_void = true
    }


    // 返回值有内容
    //  并且是: -> () 或 -> /*这是注释: 有返回值*/ ()
    if let convert = ReturnClauseSyntax(ret) {
        if convert.type.as(TupleTypeSyntax.self)?.elements.isEmpty == true {
            is_void = true
        }
    }

    // 返回值有内容, 但函数有其他类型的返回值, 
    return []
}
```

### 获取函数的返回类型
逻辑上来看函数返回可以分为2种:
1. 没有返回, 因为有多种书写情况对应函数无返回, 所以它们统称为Void
2. 非Void情况

对于非Void的情况, 可以是:
1. 直接的类型
2. 函数类型

```swift
@add
func DO() -> Int {2}
ReturnClauseSyntax
├─arrow: arrow
╰─type: IdentifierTypeSyntax        // 直接的类型返回时, 类型固定的
  ╰─name: identifier("Int")


@add
func DO() -> () -> () {{}}
ReturnClauseSyntax
├─arrow: arrow
╰─type: FunctionTypeSyntax          // 返回是()->()时, 这个返回类型本身又是函数类型的结点
  ├─leftParen: leftParen
  ├─parameters: TupleTypeElementListSyntax // 参数, 因为返回值是函数类型, 但它的参数列表是空的
  ├─rightParen: rightParen
  ╰─returnClause: ReturnClauseSyntax    // 返回值又返回的是(), 实际类型是TupleType的结点
    ├─arrow: arrow
    ╰─type: TupleTypeSyntax
      ├─leftParen: leftParen
      ├─elements: TupleTypeElementListSyntax
      ╰─rightParen: rightParen




@add
func DO() -> () -> Void {{}}
ReturnClauseSyntax                  // 返回是()->Void, 同上面一样,它本身又FunctionType
├─arrow: arrow
╰─type: FunctionTypeSyntax          
  ├─leftParen: leftParen
  ├─parameters: TupleTypeElementListSyntax   //同上, 表示返回值函数中参数列表
  ├─rightParen: rightParen          
  ╰─returnClause: ReturnClauseSyntax    // 返回值又返回Void, 它的类型不再是TupleType, 而是像Int的一样的描述
    ├─arrow: arrow
    ╰─type: IdentifierTypeSyntax
      ╰─name: identifier("Void")


@add
func DO() -> () -> Int {{2}}
ReturnClauseSyntax
├─arrow: arrow
╰─type: FunctionTypeSyntax
  ├─leftParen: leftParen
  ├─parameters: TupleTypeElementListSyntax
  ├─rightParen: rightParen
  ╰─returnClause: ReturnClauseSyntax
    ├─arrow: arrow
    ╰─type: IdentifierTypeSyntax
      ╰─name: identifier("Int")     // 同上, 结点详细描述了返回值信息
```

知道这些结构就可以获取DO函数的返回类型:

```swift
public enum Doth: PeerMacro{
    static func is_void(function: FunctionDeclSyntax) -> Bool{
        var is_void: Bool = false

        repeat {
            // 返回值部分是空的
            guard let ret = function.signature.returnClause else{
                is_void = true
                break
            }

            if ret.type.as(IdentifierTypeSyntax.self)?.name.text == "Void" {
                is_void = true
                break
            }

            if let convert = ReturnClauseSyntax(ret) {
                if convert.type.as(TupleTypeSyntax.self)?.elements.isEmpty == true {
                    is_void = true
                }
                break
            }
        } while false
        return is_void
    }

    public static func expansion(
        of node: SwiftSyntax.AttributeSyntax,
        providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
        in context: some SwiftSyntaxMacros.MacroExpansionContext)
    throws -> [SwiftSyntax.DeclSyntax] {
        // 判断声明的类型
        guard let function = declaration.as(FunctionDeclSyntax.self) else {
            return ["let Msg = \"不是函数类型\""]
        }

        repeat{
            if is_void(function: function) {
                // 返回值为Void
                break
            }

            // "Int"
            // "() -> ()"
            // "() -> Void"
            // "() -> Int"
            let type_str = function.signature.returnClause!.type.description
        }while false

        return []
    }
}
```

在函数中只能获取到返回值的字符串信息. 在整个过程中插件运行的环境由于是封闭的, 它拿到的结点信息也只是局部的, 它无法知道上下文的信息, 所以即使知道了返回类型所做的事情也很有限.

### 声明对象时的信息
声明对象也是一种声明, 所以也可以使用附加宏捕获对象的信息. 笔者这里还是借助peer来调试相关的结点

```swift
// 删除了 Msg的指定
@attached(peer, names: overloaded)
public macro add() = #externalMacro(module: "LBMacroMacros", type: "Doth")


public enum Doth: PeerMacro{
    public static func expansion(
        of node: SwiftSyntax.AttributeSyntax,
        providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
        in context: some SwiftSyntaxMacros.MacroExpansionContext)
    throws -> [SwiftSyntax.DeclSyntax] {
        return []
    }
}
```

同样的测试方式, 在测试模式下通过在调用函数中打断点, 利用lldb查看结构信息.

```swift
@add let n = 20 
VariableDeclSyntax                                      // 对象声明表达式
├─attributes: AttributeListSyntax                       // 对象有一个@add的宏属性
│ ╰─[0]: AttributeSyntax    
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax                     
├─bindingSpecifier: keyword(SwiftSyntax.Keyword.let)    // 对象是let类型
╰─bindings: PatternBindingListSyntax                    // 对象表达式绑定的信息
  ╰─[0]: PatternBindingSyntax                           // 对象表达式声明的n对象
    ├─pattern: IdentifierPatternSyntax
    │ ╰─identifier: identifier("n")
    ╰─initializer: InitializerClauseSyntax              // n的初始化信息
      ├─equal: equal                                    //  =
      ╰─value: IntegerLiteralExprSyntax                 // 初始化的值Int字面量表达式
        ╰─literal: integerLiteral("20")                 //  字面量20






@add let n = #line
VariableDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─bindingSpecifier: keyword(SwiftSyntax.Keyword.let)
╰─bindings: PatternBindingListSyntax
  ╰─[0]: PatternBindingSyntax
    ├─pattern: IdentifierPatternSyntax
    │ ╰─identifier: identifier("n")
    ╰─initializer: InitializerClauseSyntax
      ├─equal: equal
      ╰─value: MacroExpansionExprSyntax                 // 前面一样, 但这里n的值为一个表达式宏
        ├─pound: pound              
        ├─macroName: identifier("line")                 // 表达式宏的名称
        ├─arguments: LabeledExprListSyntax              // 表达式宏没有参数
        ╰─additionalTrailingClosures: MultipleTrailingClosureElementListSyntax






@add let n = {2}()
VariableDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─bindingSpecifier: keyword(SwiftSyntax.Keyword.let)
╰─bindings: PatternBindingListSyntax
  ╰─[0]: PatternBindingSyntax
    ├─pattern: IdentifierPatternSyntax
    │ ╰─identifier: identifier("n")
    ╰─initializer: InitializerClauseSyntax
      ├─equal: equal
      ╰─value: FunctionCallExprSyntax                   // n的值是通过调用一个lambda表达式的结果进行初始化的
        ├─calledExpression: ClosureExprSyntax           // 调用方式: lambda调用
        │ ├─leftBrace: leftBrace                        // {
        │ ├─statements: CodeBlockItemListSyntax         //      lambda表达式的语句列表
        │ │ ╰─[0]: CodeBlockItemSyntax                  //          第1条语句结点
        │ │   ╰─item: IntegerLiteralExprSyntax          //              第1条语句的第1个成员(2)
        │ │     ╰─literal: integerLiteral("2")          //                  该成员的值是整数字面量(2)
        │ ╰─rightBrace: rightBrace                      // }    语句列表结束     
        ├─leftParen: leftParen                          // (    产生调用
        ├─arguments: LabeledExprListSyntax              // 没有参数
        ├─rightParen: rightParen                        // )
        ╰─additionalTrailingClosures: MultipleTrailingClosureElementListSyntax






@add let n:Int
VariableDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─bindingSpecifier: keyword(SwiftSyntax.Keyword.let)
╰─bindings: PatternBindingListSyntax
  ╰─[0]: PatternBindingSyntax
    ├─pattern: IdentifierPatternSyntax
    │ ╰─identifier: identifier("n")
    ╰─typeAnnotation: TypeAnnotationSyntax              // n的类型描述
      ├─colon: colon                                    // :
      ╰─type: IdentifierTypeSyntax                      // 类型信息的描述
        ╰─name: identifier("Int")                       // 类型的信息值Int





@add var n: Int {get{20}, set{}}
VariableDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─bindingSpecifier: keyword(SwiftSyntax.Keyword.var)
╰─bindings: PatternBindingListSyntax
  ╰─[0]: PatternBindingSyntax
    ├─pattern: IdentifierPatternSyntax
    │ ╰─identifier: identifier("n")
    ├─typeAnnotation: TypeAnnotationSyntax
    │ ├─colon: colon
    │ ╰─type: IdentifierTypeSyntax
    │   ╰─name: identifier("Int")
    ╰─accessorBlock: AccessorBlockSyntax                // 对于计算属性来说, 也没有初始化结点信息, 但有accessor结点, 用来描述getter, setter
      ├─leftBrace: leftBrace
      ├─accessors: AccessorDeclListSyntax
      │ ├─[0]: AccessorDeclSyntax
      │ │ ├─attributes: AttributeListSyntax
      │ │ ├─accessorSpecifier: keyword(SwiftSyntax.Keyword.get)
      │ │ ╰─body: CodeBlockSyntax
      │ │   ├─leftBrace: leftBrace
      │ │   ├─statements: CodeBlockItemListSyntax
      │ │   │ ╰─[0]: CodeBlockItemSyntax
      │ │   │   ╰─item: IntegerLiteralExprSyntax
      │ │   │     ╰─literal: integerLiteral("20")
      │ │   ╰─rightBrace: rightBrace
      │ ╰─[1]: AccessorDeclSyntax
      │   ├─attributes: AttributeListSyntax
      │   ├─accessorSpecifier: keyword(SwiftSyntax.Keyword.set)
      │   ╰─body: CodeBlockSyntax
      │     ├─leftBrace: leftBrace
      │     ├─statements: CodeBlockItemListSyntax
      │     ╰─rightBrace: rightBrace
      ╰─rightBrace: rightBrace
```


为了应用这些信息, 笔者写一个<font color = red>编译时期存储对象值限制的案例. </font>

```swift
@attached(peer)
public macro check(_ cmpare: IntegerLiteralType) = #externalMacro(module: "LBMacroMacros", type: "Doth")
@attached(peer)
public macro check(_ cmpare: FloatLiteralType) = #externalMacro(module: "LBMacroMacros", type: "Doth")
@attached(peer)
public macro check(_ cmpare: StringLiteralType) = #externalMacro(module: "LBMacroMacros", type: "Doth")


public enum Doth: PeerMacro{
    public static func expansion(
        of node: SwiftSyntax.AttributeSyntax,
        providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
        in context: some SwiftSyntaxMacros.MacroExpansionContext)
    throws -> [SwiftSyntax.DeclSyntax] {
        guard let variable = declaration.as(VariableDeclSyntax.self) else {
            return ["let \(context.makeUniqueName("")) = \"不是在声明对象\""]
        }

        guard let arg = node.arguments?.as(LabeledExprListSyntax.self)?.first?.description else {
            return ["let \(context.makeUniqueName("")) = \"请给一个参数\""]
        }

        guard let value = variable.bindings.first?.initializer else {
            return ["let \(context.makeUniqueName("")) = \"请传递一个存储对象, 且有字面量的初值\""]
        }

        var cmp:Int = -1

        // 数值, 这里为了方便, 直接转换成Double处理, 这也表示了处理的范围最多16位的整数
        if value.value.as(PrefixOperatorExprSyntax.self) != nil ||
           value.value.as(IntegerLiteralExprSyntax.self) != nil ||
           value.value.as(FloatLiteralExprSyntax.self)   != nil{
            cmp = Double(arg)! <= Double(value.value.description)! ? 0 : 1
        }else if value.value.as(StringLiteralExprSyntax.self)  != nil  {
            cmp = arg <= value.value.description ? 0 : 2
        }

        switch cmp {
            case 0:
                return ["let _ = \"ok\""]
            case 1:
                return ["let _ = \"false(\(raw:value.value.description) >= \(raw: arg))\""]
            case 2:
                var tmp_value = value.value.description
                tmp_value.replace("\"", with: "")
                var tmp_arg = arg
                tmp_arg.replace("\"", with: "")
                return ["let _ = \"false(\(raw:tmp_value) >= \(raw: tmp_arg))\""]
            default:
                return ["let _ = \"不是字面值\""]
        }
        return []
    }
}



// 使用
@check(2)   var n1 = 1                  // false
@check(2.0) var n2 = 1.99999            // false
@check(-2)  var n3 = -2                 // ok  
@check(-2.1)var n4 = -3                 // false
@check(-2.1)var n5 = 5                  // ok
@check("abc") let s1 = "abb"            // false
@check("abc") let s2 = "ac"             // ok
```

check这个宏对键入的字面量进行比较(<font color = red>对象的值必须大于等于宏参数</font>),  该案例中没有对错误进行详细的处理, 这个到后续再完善. 该案例也可以做成动态的检查, 这个后期有精力了再完善 



### 函数参数信息
笔者认为附加宏使用在函数时, 参数部分最重要, 参数解析一般涉及到:
1. 参数名
    - 占位
    - 外部标签
    - 内部标签
2. 参数类型
3. 参数默认值
4. 尾随闭包调用
    - 可能在括号外
    - 可能在括号内
    - 这2种调用形成的结点结构不一样
5. 对参数列表修改生成新的列表
    - 并不是修改原来的列表


还是以peer为准来测试结点结构, 为了尽量简化结点信息, 都是没有返回值的函数

```swift
@add func f(a: Int) {}
FunctionDeclSyntax  
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")                     // 函数属性信息
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")                             // 函数名
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax  // 参数部分
│   ├─leftParen: leftParen                          // (
│   ├─parameters: FunctionParameterListSyntax       // 参数列表
│   │ ╰─[0]: FunctionParameterSyntax                // 第1个参数
│   │   ├─attributes: AttributeListSyntax           //  参数a没有任何属性
│   │   ├─modifiers: DeclModifierListSyntax         
│   │   ├─firstName: identifier("a")                // 外部标签
│   │   ├─colon: colon                              // 冒号
│   │   ╰─type: IdentifierTypeSyntax                // a的类型描述: 类型
│   │     ╰─name: identifier("Int")                 // a的类型描述: 值
│   ╰─rightParen: rightParen                        // )
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace 


@add func f(a b: Int) {}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: identifier("a")
│   │   ├─secondName: identifier("b")               // 内部标签
│   │   ├─colon: colon
│   │   ╰─type: IdentifierTypeSyntax
│   │     ╰─name: identifier("Int")
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace



@add func f(_ a: Int){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard                       // 外界标签是 占位符 _
│   │   ├─secondName: identifier("a")               // 内部标签
│   │   ├─colon: colon
│   │   ╰─type: IdentifierTypeSyntax
│   │     ╰─name: identifier("Int")
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace



@add func f(_ a: inout Int)
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard                   // 外部参数, 占位符
│   │   ├─secondName: identifier("a")           // 内部参数a
│   │   ├─colon: colon                          // 冒号
│   │   ╰─type: AttributedTypeSyntax            // 类型属性说明
│   │     ├─specifiers: TypeSpecifierListSyntax // 说明符列表: 即类型的修饰符
│   │     │ ╰─[0]: SimpleTypeSpecifierSyntax    // 第0个修饰符: 简单的类型说明符, 是inout
│   │     │   ╰─specifier: keyword(SwiftSyntax.Keyword.inout)
│   │     ├─attributes: AttributeListSyntax     
│   │     ╰─baseType: IdentifierTypeSyntax      // 类型信息为 Int
│   │       ╰─name: identifier("Int")
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace



@add func f(a: Int...){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: identifier("a")
│   │   ├─colon: colon
│   │   ├─type: IdentifierTypeSyntax
│   │   │ ╰─name: identifier("Int")             // Int
│   │   ╰─ellipsis: ellipsis                    // 省略号
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace





@add func f(_ a: Int = 100){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard
│   │   ├─secondName: identifier("a")
│   │   ├─colon: colon
│   │   ├─type: IdentifierTypeSyntax
│   │   │ ╰─name: identifier("Int")
│   │   ╰─defaultValue: InitializerClauseSyntax             // 参数a默认值结点
│   │     ├─equal: equal                                    //  =
│   │     ╰─value: IntegerLiteralExprSyntax                 //  参数a的默认值是一个整型表达式
│   │       ╰─literal: integerLiteral("100")                //      参数a的默认值是字面量100
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace




@add func f(_ a: Int = {100}()){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard
│   │   ├─secondName: identifier("a")
│   │   ├─colon: colon
│   │   ├─type: IdentifierTypeSyntax
│   │   │ ╰─name: identifier("Int")
│   │   ╰─defaultValue: InitializerClauseSyntax             // 参数a的默认值结点
│   │     ├─equal: equal                                    //  =
│   │     ╰─value: FunctionCallExprSyntax                   // 默认值是一个函数调用表达式
│   │       ├─calledExpression: ClosureExprSyntax           //  该表达式是闭包调用
│   │       │ ├─leftBrace: leftBrace                        //  {
│   │       │ ├─statements: CodeBlockItemListSyntax         //  闭包中实现语句结点
│   │       │ │ ╰─[0]: CodeBlockItemSyntax                  //  第1条语句结点
│   │       │ │   ╰─item: IntegerLiteralExprSyntax          //      第1条语句是整型字面量表达式
│   │       │ │     ╰─literal: integerLiteral("100")        //          第1条语句表达式值是字面量100
│   │       │ ╰─rightBrace: rightBrace                      // }
│   │       ├─leftParen: leftParen                          // (, 开始调用闭包
│   │       ├─arguments: LabeledExprListSyntax              // 闭包调用没有参数
│   │       ├─rightParen: rightParen                        // ). 结束闭包的调用
│   │       ╰─additionalTrailingClosures: MultipleTrailingClosureElementListSyntax
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace





// 尾随闭包
@add func f(_ a: (Int)-String){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard   
│   │   ├─secondName: identifier("a")
│   │   ├─colon: colon
│   │   ╰─type: FunctionTypeSyntax                          //参数a的类型结点: 是一个函数类型      
│   │     ├─leftParen: leftParen                            // 函数类型描述开始, (
│   │     ├─parameters: TupleTypeElementListSyntax          // 函数类型的参数列表结点: Tuple表达式
│   │     │ ╰─[0]: TupleTypeElementSyntax                   //  函数类型第0个参数结点
│   │     │   ╰─type: IdentifierTypeSyntax                  //      该参数类型描述
│   │     │     ╰─name: identifier("Int")                   //          参数类型的值:Int
│   │     ├─rightParen: rightParen                          // ), 函数类型的参数列表结束
│   │     ╰─returnClause: ReturnClauseSyntax                // 函数类型的返回值结点
│   │       ├─arrow: arrow                                  //  ->
│   │       ╰─type: IdentifierTypeSyntax                    //  函数类型返回值的类型描述
│   │         ╰─name: identifier("String")                  //      函数类型返回值类型的值: String
│   ╰─rightParen: rightParen                                // ), f函数的列表结束
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace





@add func f<T>(_ a: T){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─genericParameterClause: GenericParameterClauseSyntax          // 函数泛型信息结点
│ ├─leftAngle: leftAngle                                        // <
│ ├─parameters: GenericParameterListSyntax                      // 泛型参数列表结点
│ │ ╰─[0]: GenericParameterSyntax                               //  第0个泛型参数结点
│ │   ├─attributes: AttributeListSyntax             
│ │   ╰─name: identifier("T")                                   //      第0个泛型参数名T
│ ╰─rightAngle: rightAngle                                      // > 泛型信息结点结束
├─signature: FunctionSignatureSyntax            
│ ╰─parameterClause: FunctionParameterClauseSyntax              // 参数信息结点              
│   ├─leftParen: leftParen                                      // (
│   ├─parameters: FunctionParameterListSyntax                   // 参数列表结点
│   │ ╰─[0]: FunctionParameterSyntax                            //  第0个参数结点
│   │   ├─attributes: AttributeListSyntax   
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard                                   //      第0个参数外部标签, 占位符
│   │   ├─secondName: identifier("a")                           //      第0个参数内部标签a
│   │   ├─colon: colon                                          //      :
│   │   ╰─type: IdentifierTypeSyntax                            //      第0个参数的类型描述
│   │     ╰─name: identifier("T")                               //          第0个参数的类型值T
│   ╰─rightParen: rightParen
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace





protocol P {}
@add func f<T: P>(_ a: inout T){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─genericParameterClause: GenericParameterClauseSyntax          // 函数泛型结点
│ ├─leftAngle: leftAngle                                        // <
│ ├─parameters: GenericParameterListSyntax                      // 泛型参数列表
│ │ ╰─[0]: GenericParameterSyntax                               //  第0个泛型参数
│ │   ├─attributes: AttributeListSyntax 
│ │   ├─name: identifier("T")                                   //  泛型名称
│ │   ├─colon: colon                                            //  :
│ │   ╰─inheritedType: IdentifierTypeSyntax                     //  P
│ │     ╰─name: identifier("P")
│ ╰─rightAngle: rightAngle                                      // >, 该函数将泛型的约束直接在泛型列表中声明了出来
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax              // 参数结点
│   ├─leftParen: leftParen                                      // (
│   ├─parameters: FunctionParameterListSyntax                   // 参数列表
│   │ ╰─[0]: FunctionParameterSyntax                            //  第0个参数
│   │   ├─attributes: AttributeListSyntax               
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard                                   // 外部标签是一个占位符
│   │   ├─secondName: identifier("a")                           // 内部标签a
│   │   ├─colon: colon                                          // :
│   │   ╰─type: AttributedTypeSyntax                            // 参数类型又是一个结点
│   │     ├─specifiers: TypeSpecifierListSyntax                 //  类型说明符又是一个结点
│   │     │ ╰─[0]: SimpleTypeSpecifierSyntax                    //      第0个说明符
│   │     │   ╰─specifier: keyword(SwiftSyntax.Keyword.inout)   //          inout
│   │     ├─attributes: AttributeListSyntax                     
│   │     ╰─baseType: IdentifierTypeSyntax                      // 类型信息描述
│   │       ╰─name: identifier("T")                             //  类型的值为T
│   ╰─rightParen: rightParen                                    // )参数结点信息结束
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace





protocol P {}
@add func f<T>(_ a: inout T) where T: P{}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─genericParameterClause: GenericParameterClauseSyntax              // 函数中泛型相关的结点
│ ├─leftAngle: leftAngle                                            // <
│ ├─parameters: GenericParameterListSyntax                          // 泛型参数列表
│ │ ╰─[0]: GenericParameterSyntax                                   // 第0个泛型参数
│ │   ├─attributes: AttributeListSyntax                             //  第0个泛型参数没有属性说明
│ │   ╰─name: identifier("T")                                       //  参数名T
│ ╰─rightAngle: rightAngle                                          // > 泛型声明结束
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax                  // 函数参数结点
│   ├─leftParen: leftParen                                          // (
│   ├─parameters: FunctionParameterListSyntax                       //  参数列表
│   │ ╰─[0]: FunctionParameterSyntax                                // 第0个参数结点
│   │   ├─attributes: AttributeListSyntax                       
│   │   ├─modifiers: DeclModifierListSyntax                         
│   │   ├─firstName: wildcard                                       // 每1个参数的外部标签是一个占位符
│   │   ├─secondName: identifier("a")                               // 内部标签, a
│   │   ├─colon: colon                                              // :
│   │   ╰─type: AttributedTypeSyntax                                // 参数a的类型结点
│   │     ├─specifiers: TypeSpecifierListSyntax                     //  类型说明符列表
│   │     │ ╰─[0]: SimpleTypeSpecifierSyntax                        //  第1个说明符
│   │     │   ╰─specifier: keyword(SwiftSyntax.Keyword.inout)       //      inout
│   │     ├─attributes: AttributeListSyntax                         
│   │     ╰─baseType: IdentifierTypeSyntax                          //  类型的描述
│   │       ╰─name: identifier("T")                                 //      类型名称为T
│   ╰─rightParen: rightParen                                        // )
├─genericWhereClause: GenericWhereClauseSyntax                      // 函数where语句结点
│ ├─whereKeyword: keyword(SwiftSyntax.Keyword.where)                //  关键字where
│ ╰─requirements: GenericRequirementListSyntax                      // where语句中泛型限制列表
│   ╰─[0]: GenericRequirementSyntax                                 //  第0个泛型限制
│     ╰─requirement: ConformanceRequirementSyntax                   //      第0个泛型限制结点: 协议一致性
│       ├─leftType: IdentifierTypeSyntax                            //          
│       │ ╰─name: identifier("T")                                   //          该结点要求T
│       ├─colon: colon                                              //          :
│       ╰─rightType: IdentifierTypeSyntax                           
│         ╰─name: identifier("P")                                   //          P, 即要求T遵循P协议
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace






protocol P {}
func f<T>(_ a: inout T) where T: ExpressibleByIntegerLiteral & P{}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─genericParameterClause: GenericParameterClauseSyntax          // 泛型相关的结点信息
│ ├─leftAngle: leftAngle                                        // <
│ ├─parameters: GenericParameterListSyntax                      // 泛型参数列表
│ │ ╰─[0]: GenericParameterSyntax                               // 第1个泛型参数
│ │   ├─attributes: AttributeListSyntax                         
│ │   ╰─name: identifier("T")                                   // 泛型名
│ ╰─rightAngle: rightAngle                                      // >, 泛型声明结束
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax
│   ├─leftParen: leftParen
│   ├─parameters: FunctionParameterListSyntax
│   │ ╰─[0]: FunctionParameterSyntax
│   │   ├─attributes: AttributeListSyntax
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard
│   │   ├─secondName: identifier("a")
│   │   ├─colon: colon
│   │   ╰─type: AttributedTypeSyntax
│   │     ├─specifiers: TypeSpecifierListSyntax
│   │     │ ╰─[0]: SimpleTypeSpecifierSyntax
│   │     │   ╰─specifier: keyword(SwiftSyntax.Keyword.inout)   // 参数a是一个inout
│   │     ├─attributes: AttributeListSyntax                     
│   │     ╰─baseType: IdentifierTypeSyntax                      // 参数a的类型描述
│   │       ╰─name: identifier("T")                             // 类型名为T
│   ╰─rightParen: rightParen                                    
├─genericWhereClause: GenericWhereClauseSyntax                  // where语句结点
│ ├─whereKeyword: keyword(SwiftSyntax.Keyword.where)            // 关键字是where
│ ╰─requirements: GenericRequirementListSyntax                  // 泛型参数的限制说明列表
│   ╰─[0]: GenericRequirementSyntax                             //  第0个限制说明结点 
│     ╰─requirement: ConformanceRequirementSyntax               //  第0个限制说明是一致性的限制
│       ├─leftType: IdentifierTypeSyntax                        //      
│       │ ╰─name: identifier("T")                               //      要求T
│       ├─colon: colon                                          //      :
│       ╰─rightType: CompositionTypeSyntax                      //      T遵循了2个协议, 所以T遵循的2个协议被封装成结点
│         ╰─elements: CompositionTypeElementListSyntax          //          Composition是组合的意思, 即T被限制的信息结点是一个组合说明
│           ├─[0]: CompositionTypeElementSyntax                 //          
│           │ ├─type: IdentifierTypeSyntax                  
│           │ │ ╰─name: identifier("ExpressibleByIntegerLiteral")//         T要遵循ExpressibleByIntegerLiteral
│           │ ╰─ampersand: binaryOperator("&")                  //          &
│           ╰─[1]: CompositionTypeElementSyntax                 //          
│             ╰─type: IdentifierTypeSyntax
│               ╰─name: identifier("P")                         //          T要遵循P
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace




// 多参数
@add func f(_ a: Int, _ b: Int){}
FunctionDeclSyntax
├─attributes: AttributeListSyntax
│ ╰─[0]: AttributeSyntax
│   ├─atSign: atSign
│   ╰─attributeName: IdentifierTypeSyntax
│     ╰─name: identifier("add")
├─modifiers: DeclModifierListSyntax
├─funcKeyword: keyword(SwiftSyntax.Keyword.func)
├─name: identifier("f")
├─signature: FunctionSignatureSyntax
│ ╰─parameterClause: FunctionParameterClauseSyntax              // 参数结点
│   ├─leftParen: leftParen                                      // (, 参数列表开始
│   ├─parameters: FunctionParameterListSyntax                   // 参数列表结点
│   │ ├─[0]: FunctionParameterSyntax                            // 第0个参数结点
│   │ │ ├─attributes: AttributeListSyntax           
│   │ │ ├─modifiers: DeclModifierListSyntax
│   │ │ ├─firstName: wildcard
│   │ │ ├─secondName: identifier("a")                           // 内部参数名a
│   │ │ ├─colon: colon                                          // :
│   │ │ ├─type: IdentifierTypeSyntax                            
│   │ │ │ ╰─name: identifier("Int")                             // Int    
│   │ │ ╰─trailingComma: comma                                  // ,
│   │ ╰─[1]: FunctionParameterSyntax                            // 第1个参数结点
│   │   ├─attributes: AttributeListSyntax                       
│   │   ├─modifiers: DeclModifierListSyntax
│   │   ├─firstName: wildcard
│   │   ├─secondName: identifier("b")                           // 内部参数名b
│   │   ├─colon: colon                                          // :
│   │   ╰─type: IdentifierTypeSyntax            
│   │     ╰─name: identifier("Int")                             // Int
│   ╰─rightParen: rightParen                                    // )参数列表结束
╰─body: CodeBlockSyntax
  ├─leftBrace: leftBrace
  ├─statements: CodeBlockItemListSyntax
  ╰─rightBrace: rightBrace
```

这些结点信息笔者认为已经足够, 这里面需要注意: 多参数时, 参数结点会有尾部标记, 如附加上逗号. 实际开发中一般对一个函数做重载操作, 会涉及到:
1. 取出函数名
2. 解析参数列表, 如参数类型, 如参数为闭包时解析该闭包的返回类型等等
3. 对参数列表进行增删改查
4. 生成新的函数定义



### 案例1(简单重载函数)
为函数添加一个重载版本, 函数实现由用户指定(字符串形式)

```swift
// 格式:
//  @add(
//  """
//  <-#
//      用户编写的语句, 一定要是swift语句
//  #->
//  """
//  )
@attached(peer, names: overloaded)
public macro add(_ code: String = "") = #externalMacro(module: "LBMacroMacros", type: "Doth")


public static func expansion(
    of node: SwiftSyntax.AttributeSyntax,
    providingPeersOf declaration: some SwiftSyntax.DeclSyntaxProtocol,
    in context: some SwiftSyntaxMacros.MacroExpansionContext)
throws -> [SwiftSyntax.DeclSyntax] {
    guard var code = node.arguments?.description else{
        return ["let _ = \"必须提供参数\""]
    }

    guard var function = declaration.as(FunctionDeclSyntax.self) else {
        return ["let \(context.makeUniqueName("")) = \"不是函数类型\""]
    }

    // 函数名
    let func_name = function.name.text

    // 删除 @add 属性
    var idx = function.attributes.startIndex
    while true {
        if idx == function.attributes.endIndex {
            break
        }

        let f = function.attributes[idx]
        if let item = f.as(AttributeSyntax.self)?.attributeName.as(IdentifierTypeSyntax.self),
            let node_att = node.attributeName.as(IdentifierTypeSyntax.self) {

            if item.name.text == node_att.name.text {
                function.attributes.remove(at: idx)
                break;
            }
        }

        idx = function.attributes.index(after: idx)
    }


    // 参数列表
    var parm_list = function.signature.parameterClause.parameters
    if parm_list.isEmpty == false {
        //  在原函数的最后一个参数附加 ","
        parm_list[parm_list.index(before: parm_list.endIndex)].trailingComma = ","
    }
    // 插入新的参数结点
    parm_list.insert("last_parm_xxx : Int = 0", at: parm_list.endIndex)

    // 更新新的参数
    function.signature.parameterClause.parameters  = parm_list
    let ret = function.signature.returnClause?.description ?? ""


    // 处理用户输入的字符串
    //  因为在函数中拿到的字符串都是未转义的:
    //      1. 去掉 前缀的 "<-# 4个字符
    //      2. 去掉 后缀的 #->" 4个字符
    //  中间的就是用户的字符串语句
    // PS: 这里使用Foundation下的NSString, 操作起来更方便
    var code_fstr = (code as NSString)
    var begin_range = code_fstr.range(of: "<-#")
    begin_range.length += begin_range.location
    begin_range.location = 0
    code_fstr = code_fstr.replacingCharacters(in: begin_range, with: "") as NSString

    var end_range = code_fstr.range(of: "#->")
    end_range.length += code_fstr.length - (end_range.location + end_range.length)
    code_fstr = code_fstr.replacingCharacters(in: end_range, with: "") as NSString

    // 组合对应的结点:
    //  func name new_parm return_type {
    //      宏参数(用户向宏传递的字符串)
    //  }
    return [
        """
        func \(raw: func_name) \(raw: function.signature) \(raw:ret) {
            \(raw: code_fstr)
        }
        """
    ]
}


// 使用范例
@add(
"""
<-#
print("love tierry")

print("world is nice")

#->
"""
)
func f()  {}


//// 展开
func f()  {}
func f (last_parm_xxx : Int = 0)    {

    print("love tierry")

    print("world is nice")
}
```

### 案例2(伪AOP)

### 案例3(像Java一样参数过滤)


### peer
peer相对于declaration(<font color = red>声明宏</font>)和expression(<font color = red>表达式宏</font>)的来说, 它可以接收到更多的信息:
1. 它所声明元素的所有信息
2. 如果该元素是函数, 则可以获取到:
    - 函数名
    - 函数被修改的属性
    - 函数参数信息
    - 函数返回值信息
    - 等
3. 如果该元素是对象, 则可以:
    - 对象名
    - 对象类型
    - 对象属性, 如didSet, willSet等
    - 对象值
    - 等

当然它也可以修饰enum, struct, class做一些扩展操作. 
    





[^ann-result-builder]: 后面笔者以DSL来简称这个概念
[^ann-dsl]: 特定领域语言, 一般是片段式嵌入的. 这里不理解这个概念没有关系
[^ann-uikit]: 苹果iOS使用的UI框架, 基于OC语法实现的 
[^ann-mem-const]: 常量区是C程序内存布局中的一个部分, 它由操作分布, 像进程中的环境变量也位于这个区域, 该区域中的数据是只读的, 进程不能修改
</font>
